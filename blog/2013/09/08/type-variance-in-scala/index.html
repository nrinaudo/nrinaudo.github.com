
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Type variance in Scala - Dear Future Self</title>
  <meta name="author" content="Nicolas Rinaudo">

  
  <meta name="description" content="Type variance in Scala 2013-09-08 Dear future self, Type variance is a subject that I&#8217;ve long found confusing and counter-intuitive. &hellip;">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://nrinaudo.github.io/blog/2013/09/08/type-variance-in-scala">
  <link href="/images/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dear Future Self" type="application/atom+xml">
  <script src="/js/jquery.js"></script>
  <script src="/js/bootstrap-collapse.js"></script>
  <script src="/js/modernizr.js"></script>
  <script src="/js/octopress.js" type="text/javascript"></script>

  <!-- mathjax config similar to math.stackexchange -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
     jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      displayAlign: "left",
      messageStyle: "none",
      styles: {
        ".math": {
            "font-size": "80%"
        }
      },
      "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
    });
  </script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  
  

</head>

<body   >
  <div class="navbar navbar-inverse navbar-static-top">
  	<div class="navbar-inner">
  	  <div class="container">
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".navbar-responsive-collapse">
          <span class="fui-menu-24"></span>
        </a>
  	  	<div class="nav-collapse collapse navbar-responsive-collapse" style="height:0;">
  	      <ul class="nav">
    
        <li ><a href="/index.html">Home</a></li>
    
        <li ><a href="/blog/archives/index.html">Archives</a></li>
    
</ul>

<ul class="nav pull-right">
    
    <li><a href="http://github.com/nrinaudo" title="Github Profile"><i class="icon-github-sign social-navbar"></i></a></li>
    
    
    <li><a href="http://stackoverflow.com/users/1370349/nicolas-rinaudo" title="Stackoverflow Profile"><i class="icon-stackexchange social-navbar"></i></a></li>
    
    
    <li><a href="http://linkedin.com/in/nicolasrinaudo" title="Linkedin Profile"><i class="icon-linkedin-sign social-navbar"></i></a></li>
    
    
    <li><a href="http://twitter.com/NicolasRinaudo" title="Twitter Profile"><i class="icon-twitter-sign social-navbar"></i></a></li>
    
    
    
    
</ul>

  	    </div>
  	  </div>
  	</div>
  </div>
  <div class="container" id="main">
    <div class="span12">
      <div class="row-fluid">
        <div id="content">
          <div>
<article class="hentry" role="article">
  

  <header>
  <div class="jumbotron">
    Type variance in Scala
	<h5>








  


<i class="icon-calendar-empty"></i> <time datetime="2013-09-08T21:17:00+02:00" pubdate data-updated="true">2013-09-08</time></h5>
  </div>
</header>
  <div class="row-fluid">
    <div class="span12">
      <p>Dear future self,</p>

<p>Type variance is a subject that I&#8217;ve long found confusing and counter-intuitive. Attempting to use the semi-mystical
<code>[+A]</code> or <code>[-A]</code> type annotations would, more often than not, yield an obscure
<code>covariant type A occurs in contravariant position in type A...</code> compilation error.</p>

<p>I&#8217;ve finally decided to bite the bullet and make sense of it all. This post is what I came up with after hacking at /
reading on type variance until I decided I had it as figured out as I was likely to for the time being.</p>

<!-- more -->


<h2>Type variance</h2>

<p>Type variance is in itself a fairly simple concept: classes who process or store values often do not need to know the
exact type of these values, or only need them to follow a small set of constraints.</p>

<p>For example, a <code>List</code> doesn&#8217;t really need to know what it stores - it&#8217;ll behave exactly the same way whether it contains
instances of <code>Int</code> or <code>String</code>.</p>

<p>One simple way of writing the <code>List</code> class to reflect this is to have it store instances of <code>AnyRef</code>, but that would be
at the cost of type safety: since there is no constraint on the stored elements, there&#8217;s nothing to prevent a <code>List</code>
from storing instances of both <code>Int</code> and <code>String</code>.</p>

<p>Type variance allows you to turn the type of elements contained by <code>List</code> into a parameter, through the following
syntax:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// A is the type manipulated by List.</span>
</span><span class='line'><span class="k">trait</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// A can be referenced in List&#39;s body.</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">cons</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This declares a <code>List</code> trait that contains elements of type <code>A</code>, to be defined at declaration time. There&#8217;s what I feel
is an unfortunate wealth of vocabulary to describe this:</p>

<ul>
<li><code>List</code> is <em>generic</em> (it doesn&#8217;t work with a <em>specific</em> type).</li>
<li><code>List</code> is a type constructor (it accepts a parameter and defines a new type depending on this parameter&#8217;s value).</li>
<li><code>List</code> varies on <code>A</code>.</li>
</ul>


<p>Using the previous declaration of <code>List</code>, it becomes possible to write code that is both generic and type safe:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// Declares a list that will only accept instances of Int (or subclasses).</span>
</span><span class='line'><span class="k">val</span> <span class="n">li</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Works fine: 1 is an Int.</span>
</span><span class='line'><span class="n">li</span><span class="o">.</span><span class="n">cons</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Doesn&#39;t work: &quot;foobar&quot; is not an Int.</span>
</span><span class='line'><span class="n">li</span><span class="o">.</span><span class="n">cons</span><span class="o">(</span><span class="s">&quot;foobar&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that you might sometimes want to have a list of elements of any type - this is easily achieved by declaring it
as <code>List[AnyRef]</code>.</p>

<p>There are different kinds of type variance, each with its own rules for subtyping. I&#8217;ll explore these in the rest of
this post, using the following traditionnal class hierarchy for illustration:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// A Mammal has a name.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Mammal</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// A Dog is a Mammal that can bark.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Dog</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Mammal</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">bark</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;bark!&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// A Cat is a Mammal that purrs.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Cat</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Mammal</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">purr</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;purrrr&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Invariance</h2>

<p>By default, generic classes are <em>invariant</em> on their parameter(s): whatever the relation between <code>A</code> and <code>B</code>, there
won&#8217;t be any particular relationship between <code>List[A]</code> and <code>List[B]</code> - <code>B</code> could, for example, be a subclass of
<code>A</code>, but this would have no bearing on how <code>List[B]</code> relates to <code>List[A]</code>.</p>

<p><code>List</code> is a nice example in that it&#8217;s a well known structure that&#8217;s easy to reason about, but it&#8217;s a bit cumbersome
when I wish to write actual code. Let&#8217;s declare a simple <code>Wrapper</code> class, <em>invariant</em> in <code>A</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">val</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// Retrieves the wrapped value.</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">get</span> <span class="k">=</span> <span class="n">a</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Since <code>Wrapper</code> is <em>invariant</em> on its parameter, there is no relation between <code>Wrapper[Dog]</code> and <code>Wrapper[Mammal]</code>,
as shown in the following example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// Does not compile: a Wrapper[Mammal] is not an instance of Wrapper[Dog]</span>
</span><span class='line'><span class="k">val</span> <span class="n">wd</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">Dog</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Wrapper</span><span class="o">(</span><span class="k">new</span> <span class="nc">Mammal</span><span class="o">(</span><span class="s">&quot;Flipper&quot;</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Does not compile: a Wrapper[Dog] is not an instance of Wrapper[Mammal].</span>
</span><span class='line'><span class="k">val</span> <span class="n">wm</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">Mammal</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">Dog</span><span class="o">](</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">&quot;Lassie&quot;</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>That last one is a bit of a shame, though: since a <code>Dog</code> is a <code>Mammal</code>, surely a <code>Wrapper[Dog]</code> should be a
<code>Wrapper[Mammal]</code> as well? This is what <em>covariance</em> is.</p>

<h2>Covariance</h2>

<p>Saying that a class <code>C</code> is <em>covariant</em> on its parameter is saying that if <code>A</code> extends <code>B</code>, then <code>C[A]</code> extends <code>C[B]</code>.</p>

<p>In scala, making a class <em>covariant</em> on its parameter is achieved with the <code>+</code> modifier, as in the following example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="k">val</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">get</span> <span class="k">=</span> <span class="n">a</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>With <code>Wrapper</code> thus modified, our previous example works as expected:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// Does not compile: a Wrapper[Mammal] is not an instance of Wrapper[Dog]</span>
</span><span class='line'><span class="k">val</span> <span class="n">wd</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">Dog</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Wrapper</span><span class="o">(</span><span class="k">new</span> <span class="nc">Mammal</span><span class="o">(</span><span class="s">&quot;Flipper&quot;</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Now compiles: Wrapper is covariant, so a Wrapper[Dog] is a Wrapper[Mammal]</span>
</span><span class='line'><span class="k">val</span> <span class="n">wm</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">Mammal</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">Dog</span><span class="o">](</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">&quot;Lassie&quot;</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Contravariance</h2>

<p><em>Contravariance</em> is the exact opposite of <em>covariance</em>: saying that a class <code>C</code> is <em>contravariant</em> on its parameter is
saying that if <code>A</code> extends <code>B</code>, then <code>C[B]</code> extends <code>C[A]</code>.</p>

<p>In scala, making a class <em>contravariant</em> on its parameter is achieved with the <code>-</code> modifier, as in the following
example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Printer</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// Prints its argument.</span>
</span><span class='line'>  <span class="c1">// The reason why this method is named apply rather than, say, print will become clear later in this post.</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is a bit counter intuitive, but makes sense in the case of classes used to <em>process</em> rather than <em>store</em> others:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// Note how this calls a method defined in Dog but not in Mammal.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">DogPrinter</span> <span class="k">extends</span> <span class="nc">Printer</span><span class="o">[</span><span class="kt">Dog</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Dog</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>    <span class="n">a</span><span class="o">.</span><span class="n">bark</span><span class="o">()</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Since Printer is contravariant, an instance of MammalPrinter is a valid instance of Printer[Dog].</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MammalPrinter</span> <span class="k">extends</span> <span class="nc">Printer</span><span class="o">[</span><span class="kt">Mammal</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Mammal</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Compiles: a Printer[Mammal] is a valid Printer[Dog].</span>
</span><span class='line'><span class="k">val</span> <span class="n">wd</span><span class="k">:</span> <span class="kt">Printer</span><span class="o">[</span><span class="kt">Dog</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MammalPrinter</span><span class="o">()</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Does not compile: a Printer[Dog] is not a valid Printer[Mammal].</span>
</span><span class='line'><span class="c1">// If unsure why, consider what happens when DogPrinter calls the bark() method on an instance of Mammal.</span>
</span><span class='line'><span class="k">val</span> <span class="n">wm</span><span class="k">:</span> <span class="kt">Printer</span><span class="o">[</span><span class="kt">Mammal</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DogPrinter</span><span class="o">()</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Function variance</h2>

<p>Before explaining the compilation errors mentionned in the introduction of this post, we must take a closer look at
functions and how they vary on their parameters and return types.</p>

<p>In Scala, functions are instances. A unary function, for example, is an instance of <code>Function1[-T, +R]</code>, where <code>T</code> is
the type of the function&#8217;s parameter and <code>R</code> that of its return value.</p>

<p>It&#8217;s critical to understand why <code>Function1</code> is <em>contravariant</em> on its parameter type and <em>covariant</em> on its return
type: most of the complexity of type variance comes from that simple fact.</p>

<h3>Parameter type</h3>

<p>While this might not be obvious at a glance, we&#8217;ve already proven that a unary function was <em>contravariant</em> on its
parameter type.</p>

<p>The <code>Printer</code> trait we defined previously fulfills all the requirements of a unary function. We can in fact have it
extends <code>Function1[A, Unit]</code> without changing anything else in our previous code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Printer</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The conclusion we previously reached on <code>Printer</code> still applies: it must be <em>contravariant</em> on <code>A</code>, which means that
a function is <em>contravariant</em> on its parameters.</p>

<h3>Return type</h3>

<p>By the same token, we&#8217;ve already proven that a function was <em>covariant</em> on its return type: our <code>Wrapper</code> class is
a valid <code>Function1[Unit, A]</code> and can be modified as follows without changing anything else:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="k">val</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">Unit</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The conclusion we previously reached on <code>Wrapper</code> still applies: it must be <em>covariant</em> on <code>A</code>, which means that
a function is <em>covariant</em> on its return type.</p>

<h2>Explanation of the compilation errors</h2>

<h3>Covariant in contravariant position</h3>

<p>We now have all the necessary keys to understand the dreaded
<code>covariant type A occurs in contravariant position in type A...</code> error message.</p>

<p>Let&#8217;s first modify our <code>Wrapper</code> class to cause the issue:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="k">val</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// This method will cause a compilation error message.</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">va</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Wrapper</span><span class="o">(</span><span class="n">va</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Armed with our newfound type variance knowledge, this isn&#8217;t actually so hard to understand: <code>Wrapper</code> is <em>covariant</em> on
<code>A</code> while <code>set</code> is <em>contravariant</em> on <code>A</code> (its parameter type), which is clearly an issue.</p>

<p>Luckily, Scala provides an easy work around through lower type bounds:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="k">val</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Notice how the signature has changed.</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">set</span><span class="o">[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">vb</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Wrapper</span><span class="o">(</span><span class="n">vb</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>[B &gt;: A]</code> bit is telling Scala that a local type <code>B</code> has been declared, and that <code>B</code> must always be a superclass
of <code>A</code>.</p>

<p>With that modification, <code>set</code> is no longer <em>covariant</em> on <code>A</code>: its parameters are going to be of type <code>A</code> or something
more general, which respects the <em>contravariance</em> of a function&#8217;s parameter type.</p>

<p>This is all a bit theoretical, so let&#8217;s take a concrete example. Let&#8217;s pretend that the Scala compiler accepts the
following code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="k">val</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">va</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Wrapper</span><span class="o">(</span><span class="n">va</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>If this were to be considered correct, we&#8217;d be able to write the following:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">class</span> <span class="nc">BorkedWrapper</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Dog</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">Dog</span><span class="o">](</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">vd</span><span class="k">:</span> <span class="kt">Dog</span><span class="o">)</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">Dog</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// Pay attention to the fact that we&#39;re calling bark(), that&#39;s the important bit.</span>
</span><span class='line'>    <span class="n">vd</span><span class="o">.</span><span class="n">bark</span><span class="o">()</span>
</span><span class='line'>    <span class="k">new</span> <span class="nc">BorkedWrapper</span><span class="o">(</span><span class="n">vd</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Wrapper is covariant on A, and Dog is a subtype of Mammal: an instance of Wrapper[Dog] is a legal instance of</span>
</span><span class='line'><span class="c1">// Wrapper[Mammal]. The following line is perfectly legal.</span>
</span><span class='line'><span class="k">val</span> <span class="n">wd</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">Mammal</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BorkedWrapper</span><span class="o">(</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">&quot;Lassie&quot;</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// A `Cat` is a legal instance of `Mammal`, there&#39;s nothing wrong with setting one to a Wrapper[Mammal]</span>
</span><span class='line'><span class="n">wd</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="k">new</span> <span class="nc">Cat</span><span class="o">(</span><span class="s">&quot;Duchess&quot;</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Scala just let us write code that calls the <code>bark</code> method of <code>Cat</code>, which is obviously impossible - that&#8217;s where the
compilation error comes from. If were, however, to use lower type bounds, we&#8217;d find we can&#8217;t provoque such a scenario
anymore:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="k">val</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">set</span><span class="o">[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">vb</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Wrapper</span><span class="o">(</span><span class="n">vb</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// This class doesn&#39;t compile anymore: the set method doesn&#39;t actually overwrite Wrapper&#39;s, since they don&#39;t share</span>
</span><span class='line'><span class="c1">// parameter types. As an aside, that&#39;s as perfect an example of the benefit of explicitely writing override as I&#39;m</span>
</span><span class='line'><span class="c1">// likely to find: not using it here would allow the code to compile, and figuring out that we&#39;re actually declaring</span>
</span><span class='line'><span class="c1">// two different set methods might take a while.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">BorkedWrapper</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Dog</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">Dog</span><span class="o">](</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">vd</span><span class="k">:</span> <span class="kt">Dog</span><span class="o">)</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">Dog</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">vd</span><span class="o">.</span><span class="n">bark</span><span class="o">()</span>
</span><span class='line'>    <span class="k">new</span> <span class="nc">BorkedWrapper</span><span class="o">(</span><span class="n">vd</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// This doesn&#39;t compile either:</span>
</span><span class='line'><span class="c1">// - B doesn&#39;t have a bark method</span>
</span><span class='line'><span class="c1">// - new DogWrapper(vb) is not legal, since vb is not necessarily an instance of Dog.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">DogWrapper</span><span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">Dog</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">Dog</span><span class="o">](</span><span class="n">d</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">set</span><span class="o">[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">Dog</span><span class="o">](</span><span class="n">vb</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">vb</span><span class="o">.</span><span class="n">bark</span><span class="o">()</span>
</span><span class='line'>    <span class="k">new</span> <span class="nc">DogWrapper</span><span class="o">(</span><span class="n">vb</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">wd</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">Dog</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Wrapper</span><span class="o">(</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">&quot;Lassie&quot;</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// This is now legal: Mammal is a superclass of Dog, so it can be passed to set.</span>
</span><span class='line'><span class="c1">// Note that the returned value is no longer an instance of Wrapper[Dog] but of Wrapper[Mammal].</span>
</span><span class='line'><span class="k">val</span> <span class="n">wm</span><span class="k">:</span> <span class="kt">Wrapper</span><span class="o">[</span><span class="kt">Mammal</span><span class="o">]</span> <span class="k">=</span> <span class="n">wd</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="k">new</span> <span class="nc">Cat</span><span class="o">(</span><span class="s">&quot;Duchess&quot;</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Contravariant in covariant position</h3>

<p>There is of course a symmetrical issue for <em>contravariance</em>, which can be seen with the following code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Printer</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>   <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This causes the following compilation error:
<code>error: contravariant type A occurs in covariant position in type (a: A)A of method apply</code>.</p>

<p>Now that we have a good understanding of <em>contravariance</em>, <em>covariance</em> and how a function varies, this actually makes
sense: <code>Printer</code> is <em>contravariant</em> on <code>A</code> while <code>apply</code> is <em>covariant</em> on it (since <code>A</code> is <code>apply</code>&#8217;s return value).</p>

<p>We fix this the same way we did before, with type bounds - although this time we use an upper bound:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Printer</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>   <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">B</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>I&#8217;d love to give a concrete example here, but I&#8217;ve failed to find a convincing one so far. I&#8217;ll update this post if I
ever do.</p>

<h2>Mutable types and variance</h2>

<p>A last note about type variance: <em>contravariance</em> and <em>covariance</em> only work with immutable structures. Mutable ones
can be <em>invariant</em>, but they cannot be made anything else.</p>

<p>As a demonstration, let&#8217;s try to make <code>Wrapper</code> mutable:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="k">private</span> <span class="k">var</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// This won&#39;t work: a is an instance of A and cannot be used to store instances of B, since</span>
</span><span class='line'>  <span class="c1">// B is necessarily a superclass of A.</span>
</span><span class='line'>  <span class="c1">// The only way for this to work is to force B to be the same as A - which means making</span>
</span><span class='line'>  <span class="c1">// Wrapper invariant.</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">set</span><span class="o">[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">vb</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">a</span> <span class="k">=</span> <span class="n">vb</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


    </div>
  </div>



  <footer>
    <hr>
    
    <div class="row-fluid">
      <div class="span6">
        <p class="meta">
        
        



  <a href="/blog/categories/scala/"><span class="badge">scala</span></a>




        </p>
      </div>
    </div>
    
    <div class="row-fluid">
      <div class="span12">
        <p class="meta">
          
            <a class="basic-alignment left" href="/blog/2013/09/05/pattern-matching-as-parameter/" title="Previous Post: Pattern matching as parameter">&laquo; Pattern matching as parameter</a>
          
          
            <a class="basic-alignment right" href="/blog/2013/09/15/logarithm-base-in-algorithm-complexity/" title="Next Post: Logarithm base in algorithm complexity">Logarithm base in algorithm complexity &raquo;</a>
          
        </p>
      </div>
    </div>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>


        </div>
      </div>
      <div class="row-fluid">
        <footer class="footer-page" role="contentinfo">
          <p>
  Copyright &copy; 2014 - Nicolas Rinaudo
</p>


        </footer>
      </div>
    </div>
  </div>
  

<script type="text/javascript">
      var disqus_shortname = 'futureself';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://nrinaudo.github.io/blog/2013/09/08/type-variance-in-scala/';
        var disqus_url = 'http://nrinaudo.github.io/blog/2013/09/08/type-variance-in-scala/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
