<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: html | Dear Future Self]]></title>
  <link href="http://nrinaudo.github.io/blog/categories/html/atom.xml" rel="self"/>
  <link href="http://nrinaudo.github.io/"/>
  <updated>2014-01-03T14:58:29+01:00</updated>
  <id>http://nrinaudo.github.io/</id>
  <author>
    <name><![CDATA[Nicolas Rinaudo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bridging CyberNeko and Scala]]></title>
    <link href="http://nrinaudo.github.io/blog/2013/05/24/bridging-cyberneko-and-scala/"/>
    <updated>2013-05-24T22:06:00+02:00</updated>
    <id>http://nrinaudo.github.io/blog/2013/05/24/bridging-cyberneko-and-scala</id>
    <content type="html"><![CDATA[<p>Dear future self,</p>

<p>I just spent a few hours working out how to use my favourite HTML cleaner,
<a href="http://nekohtml.sourceforge.net">CyberNeko</a>, with Scala. Web scrapping is something that I have to do rather often and
I'd rather spare you the frustration I just went through, so here goes.</p>

<!-- more -->


<h2>The Problem</h2>

<p>What I wanted to do was to use CyberNeko to do the HTML parsing, but retrieve standard Scala XML elements in order to
use their various enhancements (<code>XPath</code>-like path analysis, for example).</p>

<p>The problem is that, in order to do that, one needs to use an instance of
<a href="http://www.scala-lang.org/api/2.11.0-M2/index.html#scala.xml.package@SAXParser=javax.xml.parsers.SAXParser">SAXParser</a>,
which CyberNeko doesn't provide. Well, it does provide a
<a href="http://nekohtml.sourceforge.net/javadoc/org/cyberneko/html/parsers/SAXParser.html">SAXParser</a> class, but that's a
misnomer since it's actually an implementation of
<a href="http://docs.oracle.com/javase/6/docs/api/org/xml/sax/XMLReader.html">XMLReader</a>. Confused yet?</p>

<p>After digging through Java and Xerces' mess of factories, factory adapters, builders, parsers and readers in
order to find a one-liner, elegant way to turn CyberNeko into a proper <code>SAXParser</code>, the only conclusion I came to was
that XML handling in Java is an exercise in obfucastion and it would probably be much quicker to implement a solution
than to find the appropriate classes, if they even exist.</p>

<h2>The Solution</h2>

<p>Turns out I was right. Writing a simple wrapper class for CyberNeko is as easy as:</p>

<p>```scala
import scala.xml.<em>
import org.xml.sax.</em></p>

<p>class HtmlParser extends SAXParser {
  // This is actually an instance of XMLReader. One cannot help but wonder what the !@# they were thinking.
  val reader = new org.cyberneko.html.parsers.SAXParser</p>

<p>  // By default, CyberNeko turns all element names upper-case. I'm not a big fan.
  reader.setProperty("<a href="http://cyberneko.org/html/properties/names/elems">http://cyberneko.org/html/properties/names/elems</a>", "lower")</p>

<p>  // Deprecated, no need to support.
  // This is going to generate warnings at compile time, but I don't see a way around it.
  override def getParser(): org.xml.sax.Parser = null</p>

<p>  override def getProperty(name: String): Object = reader.getProperty(name)</p>

<p>  override def getXMLReader() = reader</p>

<p>  override def isNamespaceAware() = true</p>

<p>  override def isValidating() = false</p>

<p>  override def setProperty(name: String, value: Object) = reader.setProperty(name, value)
}
```</p>

<p>Once this is done, parsing an HTML file can be done with one of
<a href="http://www.scala-lang.org/api/2.11.0-M2/index.html#scala.xml.XML">XML</a>'s various <code>load</code> methods:
```scala
val html = XML.withSAXParser(new HtmlParser()).loadFile(new java.io.File("my/html/file.html"))</p>

<p>html \ "div" foreach {div => println(div.text)}
```</p>
]]></content>
  </entry>
  
</feed>
