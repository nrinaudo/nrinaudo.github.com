<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: xml | Dear Future Self]]></title>
  <link href="http://nrinaudo.github.io/blog/categories/xml/atom.xml" rel="self"/>
  <link href="http://nrinaudo.github.io/"/>
  <updated>2014-01-03T14:58:29+01:00</updated>
  <id>http://nrinaudo.github.io/</id>
  <author>
    <name><![CDATA[Nicolas Rinaudo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Exploring XML documents with Scala]]></title>
    <link href="http://nrinaudo.github.io/blog/2013/05/26/exploring-xml-documents-with-scala/"/>
    <updated>2013-05-26T21:58:00+02:00</updated>
    <id>http://nrinaudo.github.io/blog/2013/05/26/exploring-xml-documents-with-scala</id>
    <content type="html"><![CDATA[<p>Dear future self,</p>

<p>After I worked out how to <a href="/blog/2013/05/24/bridging-cyberneko-and-scala/">load HTML</a> with Scala, I had to figure out
how to explore the resulting documents. It's rather straightfroward in
<a href="/blog/2013/04/09/using-gpath-with-xmlslurper/">Groovy</a>, but it turns out to be somewhat less pleasant in Scala.</p>

<!-- more -->


<h2>Element selectors</h2>

<p>Finding a specific element, or set of elements, is nicely implemented: it's both easy to read and to write, even if
nothing too fancy.</p>

<p>```scala
import scala.xml._</p>

<p>val xml = <html><body></p>

<pre><code>        &lt;div&gt;&lt;a href="test.html"&gt;Test&lt;/a&gt;&lt;/div&gt;
        &lt;div&gt;&lt;a href="test2.html"&gt;Test 2&lt;/a&gt;&lt;/div&gt;
      &lt;/body&gt;&lt;/html&gt;
</code></pre>

<p>// <code>\</code> returns a sequence containing all elements whose name match the right operand and are direct descendants of the
// left operand.
// Prints:
// <div><a href="test.html">Test</a></div>
// <div><a href="test2.html">Test 2</a></div>
xml \ "body" \ "div" foreach println</p>

<p>// <code>\\</code> returns a sequence containing all elements whose name match the right operand, regardless of their depth.
// Prints:
// <a href="test.html">Test</a>
// <a href="test2.html">Test 2</a>
xml \ "a" foreach println
```</p>

<p>The <code>\</code> and <code>\\</code> selectors return sequences: you can call <code>filter</code>, <code>map</code>, <code>foreach</code>... on their results.</p>

<h2>Attribute selectors</h2>

<p>Selecting an attribute appears simple at first. According to the documentation, you can simply use <code>@name</code> with the
standard <code>\</code> and <code>\\</code> selectors, which sounds brilliant until you realise it doesn't actually work as advertised.</p>

<p>```scala
import scala.xml._</p>

<p>val xml = <html><body></p>

<pre><code>        &lt;div&gt;&lt;a href="test.html"&gt;Test&lt;/a&gt;&lt;/div&gt;
        &lt;div&gt;&lt;a href="test2.html"&gt;Test 2&lt;/a&gt;&lt;/div&gt;
      &lt;/body&gt;&lt;/html&gt;
</code></pre>

<p>// This <em>should</em> match and print the href attribute of all a elements.
// It doesn't actually work, though, and doesn't print anything.
xml \ "a" \ "@href" foreach println</p>

<p>// This does what the previous code should do. Not terribly elegant, but gets the job done.
// Prints:
// test.html
// test2.html
xml \ "a" map {_ \ "@href"} foreach println</p>

<p>// Matches and prints all href attributes, regardless of their parent element.
// Prints:
// test.html
// test2.html
xml \ "@href" foreach println</p>

<p>```</p>

<h2>Filtering on attribute</h2>

<p>This is where things take a turn for the worse, as far as I'm concerned: you <em>can</em> filter on attributes, it's just not
very pleasant at all.</p>

<p>```scala
import scala.xml._</p>

<p>val xml = <html><body></p>

<pre><code>        &lt;div&gt;&lt;a href="test.html"&gt;Test&lt;/a&gt;&lt;/div&gt;
        &lt;div&gt;&lt;a href="test2.html"&gt;Test 2&lt;/a&gt;&lt;/div&gt;
        &lt;div&gt;&lt;a&gt;No Link&lt;/a&gt;&lt;/div&gt;
      &lt;/body&gt;&lt;/html&gt;
</code></pre>

<p>// Finds all a elements whose href attribute exists.
// Prints:
// <a href="test.html">Test</a>
// <a href="test2.html">Test 2</a>
xml \ "a" filter {a => !(a \ "@href").isEmpty} foreach println</p>

<p>// Finds all a elements whose href attribute is equal to test.html.
// Prints:
// <a href="test.html">Test</a>
xml \ "a" filter {_ \ "@href" contains Text("test.html")} foreach println
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bridging CyberNeko and Scala]]></title>
    <link href="http://nrinaudo.github.io/blog/2013/05/24/bridging-cyberneko-and-scala/"/>
    <updated>2013-05-24T22:06:00+02:00</updated>
    <id>http://nrinaudo.github.io/blog/2013/05/24/bridging-cyberneko-and-scala</id>
    <content type="html"><![CDATA[<p>Dear future self,</p>

<p>I just spent a few hours working out how to use my favourite HTML cleaner,
<a href="http://nekohtml.sourceforge.net">CyberNeko</a>, with Scala. Web scrapping is something that I have to do rather often and
I'd rather spare you the frustration I just went through, so here goes.</p>

<!-- more -->


<h2>The Problem</h2>

<p>What I wanted to do was to use CyberNeko to do the HTML parsing, but retrieve standard Scala XML elements in order to
use their various enhancements (<code>XPath</code>-like path analysis, for example).</p>

<p>The problem is that, in order to do that, one needs to use an instance of
<a href="http://www.scala-lang.org/api/2.11.0-M2/index.html#scala.xml.package@SAXParser=javax.xml.parsers.SAXParser">SAXParser</a>,
which CyberNeko doesn't provide. Well, it does provide a
<a href="http://nekohtml.sourceforge.net/javadoc/org/cyberneko/html/parsers/SAXParser.html">SAXParser</a> class, but that's a
misnomer since it's actually an implementation of
<a href="http://docs.oracle.com/javase/6/docs/api/org/xml/sax/XMLReader.html">XMLReader</a>. Confused yet?</p>

<p>After digging through Java and Xerces' mess of factories, factory adapters, builders, parsers and readers in
order to find a one-liner, elegant way to turn CyberNeko into a proper <code>SAXParser</code>, the only conclusion I came to was
that XML handling in Java is an exercise in obfucastion and it would probably be much quicker to implement a solution
than to find the appropriate classes, if they even exist.</p>

<h2>The Solution</h2>

<p>Turns out I was right. Writing a simple wrapper class for CyberNeko is as easy as:</p>

<p>```scala
import scala.xml.<em>
import org.xml.sax.</em></p>

<p>class HtmlParser extends SAXParser {
  // This is actually an instance of XMLReader. One cannot help but wonder what the !@# they were thinking.
  val reader = new org.cyberneko.html.parsers.SAXParser</p>

<p>  // By default, CyberNeko turns all element names upper-case. I'm not a big fan.
  reader.setProperty("<a href="http://cyberneko.org/html/properties/names/elems">http://cyberneko.org/html/properties/names/elems</a>", "lower")</p>

<p>  // Deprecated, no need to support.
  // This is going to generate warnings at compile time, but I don't see a way around it.
  override def getParser(): org.xml.sax.Parser = null</p>

<p>  override def getProperty(name: String): Object = reader.getProperty(name)</p>

<p>  override def getXMLReader() = reader</p>

<p>  override def isNamespaceAware() = true</p>

<p>  override def isValidating() = false</p>

<p>  override def setProperty(name: String, value: Object) = reader.setProperty(name, value)
}
```</p>

<p>Once this is done, parsing an HTML file can be done with one of
<a href="http://www.scala-lang.org/api/2.11.0-M2/index.html#scala.xml.XML">XML</a>'s various <code>load</code> methods:
```scala
val html = XML.withSAXParser(new HtmlParser()).loadFile(new java.io.File("my/html/file.html"))</p>

<p>html \ "div" foreach {div => println(div.text)}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using GPath with XmlSlurper]]></title>
    <link href="http://nrinaudo.github.io/blog/2013/04/09/using-gpath-with-xmlslurper/"/>
    <updated>2013-04-09T21:28:00+02:00</updated>
    <id>http://nrinaudo.github.io/blog/2013/04/09/using-gpath-with-xmlslurper</id>
    <content type="html"><![CDATA[<p>Dear future self,</p>

<p>Writing quick, discardable tools to parse some sort of XML, extract information from it and put it somewhere else is
something I have to do with some regularity.</p>

<p>The best tool I currently have for this is Groovy - it has access to the wealth of existing Java libraries, but with a
much more flexible syntax that does away with most of its parent's boilerplate.</p>

<p>Also, mostly, <code>XmlSlurper</code> and GPath. These make loading and extracting information from XML so smooth and easy that
one would almost forget the nightmare Java's internal XML APIs can be.</p>

<p>That's the theory, at least, but it doesn't appear to work for me. Whenever I have to use GPath, I find myself
stimmied by the same problems. Time and time again, I'll forget the difference between <code>grep</code> and <code>find</code>, or fail to
remember that detph- or breadth-first searches change the rules slightly.</p>

<p>Not anymore. Since my brain obviously has some sort of block as far as GPath syntax is concerned, this post will do in
its stead.</p>

<!-- more -->


<p>In the rest of this post, the <code>xml</code> object is assumed to have been obtained through one of <code>XmlSlurper</code>'s <code>parse</code>
methods.</p>

<h2>Finding an element by name</h2>

<p>The first things I <em>always</em> stumble on is when attempting to find all the elements of one type contained in an XML
document - say, for example, all <code>li</code> elements in an HTML file.</p>

<p>What I want to write is:
```groovy
xml.'**'.li.each {</p>

<pre><code>// processing code
</code></pre>

<p>}
```</p>

<p>And, for some reason, I <em>always</em> distinctly remember having done so in the past.</p>

<p>Well, future self, you're wrong. This syntax isn't supported, nor, as far as I can tell, has it ever been. Don't try to
get it to work.</p>

<p><code>**</code> is an alias for <code>depthFirst()</code>, which returns an iterator - a Groovy enhanced one, certainly, but still not one
that supports nested GPath expressions.</p>

<p>Here's what you want to do:</p>

<p>```groovy
xml.'**'.findAll {it.name() == 'li'}.each {</p>

<pre><code>// processing code
</code></pre>

<p>}
```</p>

<p>Pay attention to the way the element's name is retrieved: it's <code>it.name()</code>, not <code>it.name</code>. A method, not a property. And
yes, I know you feel vaguely insulted by what seems like such a stupid decision, but there's a very good reason for it:
properties describe children of the current node, so <code>it.name</code> would referrer to a <code>name</code> child element rather than the
element's name.</p>

<p>Honestly, if past me had told me that this morning, I'd have saved a good half hour this afternoon.</p>

<h2>grep VS find VS findAll</h2>

<p>These three methods have very similar contracts and purposes, but differ in ways that always do my head in.</p>

<p>I'll use the following input to illustrate these differences:
```xml
<html></p>

<pre><code>&lt;body&gt;
    &lt;ul&gt;
        &lt;li class="odd"&gt;&lt;span&gt;Element 1&lt;/span&gt;&lt;/li&gt;
        &lt;li class="even"&gt;&lt;span&gt;Element 2&lt;/span&gt;&lt;/li&gt;
        &lt;li class="odd"&gt;&lt;span&gt;Element 3&lt;/span&gt;&lt;/li&gt;
        &lt;li class="even"&gt;&lt;span&gt;Element 4&lt;/span&gt;&lt;/li&gt;
        &lt;li class="odd"&gt;&lt;span&gt;Element 5&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<h3>find</h3>

<p><code>find</code> is the simplest of the three: it returns the first node for which its closure argument returns <code>true</code>.</p>

<p>For example:
```groovy
// Finds the first li element with a class attribute of odd.
// Outputs 'Element 1'.
xml.body.ul.li.find {it.@class == 'odd'}.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
```</p>

<p>The returned value is an instance of <code>NodeChild</code>, which is convenient: you've just essentially obtained the root of a
sub-tree of your original XML document, and can treat it exactly as you did the <code>xml</code> object - by, for example, chaining additional GPath filters.</p>

<p>The following example is perfectly valid (and convenient):
```groovy
// Outputs 'Element 1'
xml.body.ul.li.find {it.@class == 'odd'}.span.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
```</p>

<p>Bear in mind that, once you've called <code>find</code>, you've restricted yourself to the <em>first</em> element that matched your
closure <em>only</em>. I'm sure normal people don't have a problem with that, but it seems to slip my mind very often.</p>

<h3>findAll</h3>

<p><code>findAll</code> is also fairly simple: it returns all nodes for which its closure argument returns <code>true</code>.</p>

<p>For example:
```groovy
// Finds all li elements with a class attribute of odd.
// Outputs 'Element 1\nElement 3\nElement 5\n'
xml.body.ul.li.findAll {it.@class == 'odd'}.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
```</p>

<p>The returned value is an instance of <code>FilteredNodeChildren</code>, a subclass of <code>GPathResult</code>, which <em>should</em> be nice but
looks... unfinished.</p>

<p>It basically supports the same nested GPath filters as <code>find</code>, with one very notable exception.
```groovy
// Does exactly what you'd expect: prints 'odd\nodd\nodd\n'
xml.body.ul.li.findAll {it.@class == 'odd'}.@class.each {println it.text()}</p>

<p>// Doesn't do what you'd expect at all: no span element is found.
xml.body.ul.li.findAll {it.@class == 'odd'}.span.each {println it.text()}
```</p>

<p>This has had me scratching my head for a while, but I can't find a reason why the <code>span</code> selector doesn't work. I'm not
confident enough in my Groovy skills to call this a bug in the standard APIs, but looking at the corresponding code, it
looks like it should work but doesn't.</p>

<p>The only solution I could find was to use the
<a href="http://groovy.codehaus.org/Operators#Operators-SpreadOperator">spread operator</a> as follows:
<code>groovy
// Outputs 'Element 1\nElement 3\nElement 5\n'
xml.body.ul.li.findAll {it.@class == 'odd'}*.span.each {println it.text()}
</code></p>

<p>While this works, I find it unsatisfactory: it looks out of place in what is an otherwise fairly clean GPath expression.
I'll keep looking and update this post should I find a reason, but for the moment, future self, bear in mind that
<code>findAll</code> feels a bit broken. You'd want its result to be manipulable in exactly the same way <code>find</code>'s result is, but
this is just not the case.</p>

<p><em>Edit: this is apparently a reported <a href="https://jira.codehaus.org/browse/GROOVY-6122">bug</a> and will hopefully be fixed
eventually</em></p>

<h3>grep</h3>

<p><code>grep</code> is where I usually get stuck. At a glance, its signature and purpose are the same as <code>findAll</code>'s.</p>

<p>For example:
```groovy
// Finds all li elements with a class attribute of odd.
// Outputs 'Element 1\nElement 3\nElement 5\n'
xml.body.ul.li.grep {it.@class == 'odd'}.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
```</p>

<p>There are, however, two differences between <code>findAll</code> and <code>grep</code>'s signatures.</p>

<p>The first one is that <code>grep</code>'s argument isn't a closure but an object whose <code>isCase(Object)</code> method will be evaluated.
You can pass in a closure, in which case the behaviour will be identical to that of <code>findAll</code>, but you could also pass
any object with a useful <code>isCase</code> method.</p>

<p>The second difference is in the return type: <code>ArrayList&lt;NodeChild&gt;</code>. Groovy collections have a fun if sometimes
misleading feature used to simplify calls to <code>collect</code>. The following calls are strictly equivalent:
```groovy
def set = ['foo', 'bar']</p>

<p>// Returns ['foo'.bytes, 'bar'.bytes]
set.collect {it.bytes}</p>

<p>// Does the same thing in a slightly more idiomatic way.
set.bytes
```</p>

<p>This means that the following code is perfectly correct, and will behave exactly as one would expect:
```groovy
xml.body.ul.li.grep {it.@class == 'odd'}.span.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
```</p>

<p>Which is brilliant, until you write the following:
```groovy
xml.body.ul.li.grep {it.@class == 'odd'}.'**'.findAll {it.name() == 'span'}.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
<code>
This, as it turns out, throws an exception that is frustrating to understand. So, future self, here's exactly what
happens laid out in simple terms:
</code>groovy
// 'nodes' is an ArrayList<NodeChild>
def nodes = xml.body.ul.li.grep {it.@class == 'odd'}</p>

<p>// This is strictly equivalent to nodes.collect {it.'<strong>'}.
// 'search' isn't an Iterator<NodeChild> but an ArrayList&lt;Iterator<NodeChild>>
def search = nodes.'</strong>'</p>

<p>// You'd expect 'it' to be a NodeChild, but you actually get an Iterator<NodeChild>.
// Iterators don't support the name() method, which is where the exception is raised.
search.findAll {it.name() == 'span'}.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
