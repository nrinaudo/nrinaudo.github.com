<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Dear Future Self]]></title>
  <link href="http://nrinaudo.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://nrinaudo.github.io/"/>
  <updated>2014-01-03T14:47:43+01:00</updated>
  <id>http://nrinaudo.github.io/</id>
  <author>
    <name><![CDATA[Nicolas Rinaudo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Overridable methods in constructors]]></title>
    <link href="http://nrinaudo.github.io/blog/2013/04/05/overridable-methods-in-constructors/"/>
    <updated>2013-04-05T16:06:00+02:00</updated>
    <id>http://nrinaudo.github.io/blog/2013/04/05/overridable-methods-in-constructors</id>
    <content type="html"><![CDATA[<p>Dear future self,</p>

<p>A code quality issue that I seem to be particularly prone to is
<a href="http://pmd.sourceforge.net/pmd-4.3.0/rules/design.html#ConstructorCallsOverridableMethod">calling an overridable method within a constructor</a>.
Whenever one of my various code quality metrics tools spits out a warning about this practice, I get a bit annoyed
and need to be convinced it's a bad idea all over again. This post's purpose is to speed up that process.</p>

<!-- more -->


<p>Overridable methods in a constructor are a bad idea because of a very simple fact: a class' parent's constructor is
always called before the class' constructor is executed. When not called explicitely, the compiler will add an implicit
call to the parent's default constructor.</p>

<p>Most Java developers understand that, and I know <em>I</em> do, but a fair amount of us still get caught unawares by the
implications.</p>

<p>Let's take a concrete example. The following class looks very simple and harmless:
``` java
public class Parent {</p>

<pre><code>public Parent() {
    demonstrate();
}

public void demonstrate() {
    // Left for sub-classes to override.
}
</code></pre>

<p>}
```</p>

<p>However, it turns out to be a nasty trap, sprung by the following code:
``` java
public class Child extends Parent {</p>

<pre><code>// Both private and final: most sane people will assume its value cannot change.
private final String field;

// The first thing we do is set "field"'s value.
public Child(String value) {
    field = value;
}

public void demonstrate() {
    System.out.println(field);
}

public static void main(String... args) {
    // You'd expect this to result in "Hello, World!" being printed to stdout.
    new Child("Hello, World!");
}
</code></pre>

<p>}
```</p>

<p>This is fairly straightforward, but the result isn't what one would expect: it prints <code>null</code> to stdout rather than
<code>Hello, World!</code>.</p>

<p>If you think about it, that's actually logical: <code>Parent</code>'s constructor is called before <code>Child</code>'s is, which means that
<code>demonstrate()</code> is called before <code>field</code>'s value is set.</p>

<p>It's only obvious because we have access to <code>Parent</code>'s source code and we know what to look for, however. One of the
symptoms is that an immutable field has a different value from the one we clearly assigned it - I know I'd be tempted to
blame the compiler, since this is clearly impossible.</p>
]]></content>
  </entry>
  
</feed>
