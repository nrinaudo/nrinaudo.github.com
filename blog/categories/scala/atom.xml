<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: scala | Dear Future Self]]></title>
  <link href="http://nrinaudo.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://nrinaudo.github.io/"/>
  <updated>2014-01-03T22:07:29+01:00</updated>
  <id>http://nrinaudo.github.io/</id>
  <author>
    <name><![CDATA[Nicolas Rinaudo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Always use the tailrec annotation]]></title>
    <link href="http://nrinaudo.github.io/blog/2013/11/05/always-use-the-tailrec-annotation/"/>
    <updated>2013-11-05T14:29:00+01:00</updated>
    <id>http://nrinaudo.github.io/blog/2013/11/05/always-use-the-tailrec-annotation</id>
    <content type="html"><![CDATA[<p>Deaf future self,</p>

<p>I’ve been asked a few times why I try to systematically use the <code>@scala.annotation.tailrec</code> annotation - surely I’m smart
enough to know when my code is tail-recursive?</p>

<!-- more -->


<p>The simple answer is that you cannot always know or remember all the reasons why the compiler might refuse to optimise
your code for tail-recursion - or at least realise that your code exhibits such symptoms.</p>

<p>A simple example I discovered recently is overridable methods. The following code shows a method that looks fairly
tail-recursive (even if singularly useless) at a glance, but really isn’t:</p>

<p>```scala
class Demo {
  def countDown(i: Int): Int =</p>

<pre><code>if(i == 0) 0
else       countDown(i - 1)
</code></pre>

<p>}</p>

<p>// Causes a StackOverflowError
new Demo().countDown(Int.MaxValue)
```</p>

<p>Adding the <code>@scala.annotation.tailrec</code> annotation allows the compiler to warn me of the issue before my code blows up in
production: <code>error: could not optimize @tailrec annotated method countDown: it is neither private nor final so can be
overridden.</code></p>

<p>It also provides enough of a hint to work out an acceptable solution:
```scala
class Demo {
  def countDown(i: Int): Int = {</p>

<pre><code>@scala.annotation.tailrec
def run(i: Int): Int =
  if(i == 0) 0
  else       run(i - 1)
run(i)
</code></pre>

<p>  }
}</p>

<p>// Runs all the way to the end.
new Demo().countDown(Int.MaxValue)
```</p>

<p>Having the recursive code in a nested function ensures that it cannot be overridden, which allows the compiler to
optimise it for tail-recursion. <code>countDown</code> is now safe to call, but I’d never even realised there was a potential issue
without the <code>tailrec</code> annotation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type classes in Scala]]></title>
    <link href="http://nrinaudo.github.io/blog/2013/10/21/type-classes-in-scala/"/>
    <updated>2013-10-21T16:37:00+02:00</updated>
    <id>http://nrinaudo.github.io/blog/2013/10/21/type-classes-in-scala</id>
    <content type="html"><![CDATA[<p>Deaf future self,</p>

<p>I've recently noticed how often <em>type classes</em> came up in discussions about Scala, and how I had no idea what it meant.
It turns out to be a much simpler concept than expected, and a very powerfull one too.</p>

<!-- more -->


<h2>Purpose</h2>

<p>Type classes are used to retroactively add features to classes <em>without modifying them</em>.</p>

<p>Say, for example, that you're using an external library that exposes a <code>Person</code> class, implemented as follows:</p>

<p><code>scala
case class Person(first: String, last: String) {
  override def toString = "%s %s" format (first, last)
}
</code></p>

<p>Your application holds a <code>List</code> of <code>Person</code> instances, and you'd like to sort them, say, alphabetically by family name.
At this point, if the external library hasn't already made <code>Person</code> sortable, you have very few options.</p>

<p>The first one is to create an adapter that implements
<a href="http://www.scala-lang.org/api/current/index.html#scala.math.Ordered">Ordered</a>:</p>

<p>```scala
class OrderedPerson(val wrapped: Person) extends Ordered[OrderedPerson] {
  override def compare(that: OrderedPerson): Int = wrapped.last.compareTo(that.wrapped.last)</p>

<p>  override def toString = wrapped.toString
}
```</p>

<p>This works, but with a few flaws:</p>

<ul>
<li>you're not working with instances of <code>Person</code> anymore, and need to transform your objects back and forth (or have
<code>OrderedPerson</code> extend <code>Person</code> and proxy every single method)</li>
<li>implementing multiple sorting strategies (by first name, for example) is possible but requires a lot of legwork</li>
</ul>


<p>The other solution is using <a href="http://www.scala-lang.org/api/current/index.html#scala.math.Ordering">Ordering</a>
as follows:</p>

<p><code>scala
implicit object LastNameOrdering extends Ordering[Person] {
  override def compare(a: Person, b: Person): Int = a.last.compareTo(b.last)
}
</code></p>

<p>Since all Scala methods that sort objects accept an instance of <code>Ordering</code> (<code>List.sorted</code>, <code>Sorting.quickSort</code>...),
<code>LastNameOrdering</code> has just retrofitted <code>Person</code> with the ability to be sorted without actually modifying its code.
Implementing another sorting strategy is simply done by writing another implementation of <code>Ordering</code>. Additionally,
since all methods that expect an instance of <code>Ordering</code> declare it as an implicit parameter, and we've made
<code>LastNameOrdering</code> an implicit object, we don't even need to explicitly pass it around - as long as it's in scope, it
will be used automatically by the compiler.</p>

<p><code>Ordering</code> is a perfect example of what a type class is. Using technical words, the adapter pattern uses <em>subtype
polymorphism</em> while type classes use <em>parametric polymorphism</em>.</p>

<h2>Writing a type class</h2>

<p>We now have a better understanding of what a type class is. Implementing one requires surprisingly little code and,
thanks to Scala's support of implicit parameters, can be made all but invisible to callers.</p>

<p>Let's say that our application requires a facility for printing <code>Person</code> to <code>stdout</code>. A naive first implementation could
be:</p>

<p><code>scala
object Printer {
  def print(p: Person) = println(p)
}
</code></p>

<p>This works, but is very limiting:</p>

<ul>
<li>the only supported format is that implemented by the <code>toString</code> method, and we'd need to write adapter classes for
each format we want to add</li>
<li>it only works for <code>Person</code> - what if we have another <code>Company</code> class that we'd like to print to stdout as well? Do we
need to write an entirely different printing facility for that?</li>
</ul>


<p>This is were type classes really shine. Instead of letting the object being printed decide how to format itself, we
create a trait and delegate that responsability to it:</p>

<p>```scala
// Used solely for the purpose of formatting instances of A.
trait Formatter[A] {
  def format(a: A): String
}</p>

<p>object Printer {
  // Now accepts two parameters: an object to print, and an object that knows how to format it.
  def print<a href="a:%20A,%20f:%20Formatter[A]">A</a> = println(f.format(a))
}</p>

<p>// Person specific formatter.
object PersonFormatter extends Formatter[Person] {
  override def format(a: Person) = a.last
}</p>

<p>// We've now entirely de-coupled Person and its formatting mechanism.
Printer.print(new Person("Robert", "Smith"), PersonFormatter)
```</p>

<p>This is nice but a bit verbose. As usual, Scala has mechanism to reduce the verbosity: implicit parameters.</p>

<p>```scala
object Printer {
  // The formatter is now an implicit parameter.
  def print<a href="a:%20A">A</a>(implicit f: Formatter[A]) = println(f.format(a))
}</p>

<p>// Declares an implicit Formatter[Person] in scope.
implicit object PersonFormatter extends Formatter[Person] {
  override def format(a: Person) = a.last
}</p>

<p>// We can now omit the formatter entirely.
Printer.print(new Person("Robert", "Smith"))
```</p>

<p>From Scala 2.8 onwards, the same can be achieved through context bounds:
<code>scala
object Printer {
  // [A: Formatter] should be read as "class that has an associated implicit Formatter".
  def print[A: Formatter](a: A) = println(implicitly[Formatter[A]].format(a))
}
</code></p>

<p>Not only have we added a new formatting feature to <code>Person</code> without modifying its source code or extending it, but
we've also done it for all possible classes. Nothing in our implementation ties us to <code>Person</code>: adding support for, say,
dates, is simply done by writing a <code>Formatter</code> implementation for <code>Date</code>.</p>

<p>```scala
import java.util.Date</p>

<p>// Formats dates as legal ISO 8601 strings.
implicit object DateFormatter extends Formatter[Date] {
  private val formatter = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssz")
  override def format(date: Date) = formatter.format(date)
}</p>

<p>// Since DateFormatter is both implicit and in scope, there's no need to pass it explicitly.
Printer.print(new Date())
```</p>

<h2>Type safety</h2>

<p>Another advantage of type classes is that, since they're validated at compile time, they're inherently safe. Subtype
polymorphism is mostly safe, but must rely on trust in some cases. The following (contrived) example compiles, but fails
at runtime:</p>

<p>```scala
def print(a: Any) = println(a.asInstanceOf[Person].first)</p>

<p>print(new java.util.Date())
```</p>

<p>Such a situation is not possible with type classes, where all types are know to and validated by the compiler.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Regular expressions in pattern matching]]></title>
    <link href="http://nrinaudo.github.io/blog/2013/09/21/regular-expressions-in-pattern-matching/"/>
    <updated>2013-09-21T19:00:00+02:00</updated>
    <id>http://nrinaudo.github.io/blog/2013/09/21/regular-expressions-in-pattern-matching</id>
    <content type="html"><![CDATA[<p>Dear future self,</p>

<p>While reading <code>Regex</code>'s
<a href="http://www.scala-lang.org/files/archive/nightly/docs/library/index.html#scala.util.matching.Regex">documentation</a>, I
discovered that it had a legal <code>unapplySeq</code> implementation. This means that it can be used in pattern matching, which
I'm not sure is going to be terribly useful but is certainly very cool.</p>

<!-- more -->


<p>The most immediate use of <code>Regex</code>'s <code>unapplySeq</code> method is to let us write code like this:
```scala
import scala.util.matching._</p>

<p>// The usual 2D point class, with a horizontal and vertical coordinate.
case class Point(x: Int = 0, y: Int = 0) {
  // Note the .r at the end of each line, which transforms a string into an instance of Regex
  private val left   = "left ([0-9]+)".r
  private val right  = "right ([0-9]+)".r
  private val top    = "top ([0-9]+)".r
  private val bottom = "bottom ([0-9]+)".r</p>

<p>  // The beauty of pattern matching with regular expressions.
  def handle(s: String): Point = s match {</p>

<pre><code>case left(p)   =&gt; Point(x - p.toInt, y)
case right(p)  =&gt; Point(x + p.toInt, y)
case top(p)    =&gt; Point(x, y - p.toInt)
case bottom(p) =&gt; Point(x, y + p.toInt)
</code></pre>

<p>  }
}</p>

<p>// Prints 'Point(-10,5)'
println(Point().handle("left 10").handle("bottom 5"))
```</p>

<p>Another fun use, but one that I don't think I'll be using in live code because of how odd it can be to read, is to
parse and assign variables at definition time:
```scala
val point = "\(([0-9]+),([0-9]+)\)".r</p>

<p>// It might be because I haven't seen this pattern enough yet, but I always read this as calling a function
// on variables that haven't been defined yet.
val point(x, y) = "(10,12)"</p>

<p>// Prints '10 / 12'
println("%s / %s" format (x, y))
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type variance in Scala]]></title>
    <link href="http://nrinaudo.github.io/blog/2013/09/08/type-variance-in-scala/"/>
    <updated>2013-09-08T21:17:00+02:00</updated>
    <id>http://nrinaudo.github.io/blog/2013/09/08/type-variance-in-scala</id>
    <content type="html"><![CDATA[<p>Dear future self,</p>

<p>Type variance is a subject that I've long found confusing and counter-intuitive. Attempting to use the semi-mystical
<code>[+A]</code> or <code>[-A]</code> type annotations would, more often than not, yield an obscure
<code>covariant type A occurs in contravariant position in type A...</code> compilation error.</p>

<p>I've finally decided to bite the bullet and make sense of it all. This post is what I came up with after hacking at /
reading on type variance until I decided I had it as figured out as I was likely to for the time being.</p>

<!-- more -->


<h2>Type variance</h2>

<p>Type variance is in itself a fairly simple concept: classes who process or store values often do not need to know the
exact type of these values, or only need them to follow a small set of constraints.</p>

<p>For example, a <code>List</code> doesn't really need to know what it stores - it'll behave exactly the same way whether it contains
instances of <code>Int</code> or <code>String</code>.</p>

<p>One simple way of writing the <code>List</code> class to reflect this is to have it store instances of <code>AnyRef</code>, but that would be
at the cost of type safety: since there is no constraint on the stored elements, there's nothing to prevent a <code>List</code>
from storing instances of both <code>Int</code> and <code>String</code>.</p>

<p>Type variance allows you to turn the type of elements contained by <code>List</code> into a parameter, through the following
syntax:
<code>scala
// A is the type manipulated by List.
trait List[A] {
  // A can be referenced in List's body.
  def cons(a: A): List[A]
}
</code></p>

<p>This declares a <code>List</code> trait that contains elements of type <code>A</code>, to be defined at declaration time. There's what I feel
is an unfortunate wealth of vocabulary to describe this:</p>

<ul>
<li><code>List</code> is <em>generic</em> (it doesn't work with a <em>specific</em> type).</li>
<li><code>List</code> is a type constructor (it accepts a parameter and defines a new type depending on this parameter's value).</li>
<li><code>List</code> varies on <code>A</code>.</li>
</ul>


<p>Using the previous declaration of <code>List</code>, it becomes possible to write code that is both generic and type safe:
```scala
// Declares a list that will only accept instances of Int (or subclasses).
val li: List[Int] = // ...</p>

<p>// Works fine: 1 is an Int.
li.cons(1)</p>

<p>// Doesn't work: "foobar" is not an Int.
li.cons("foobar")
```</p>

<p>Note that you might sometimes want to have a list of elements of any type - this is easily achieved by declaring it
as <code>List[AnyRef]</code>.</p>

<p>There are different kinds of type variance, each with its own rules for subtyping. I'll explore these in the rest of
this post, using the following traditionnal class hierarchy for illustration:
```scala
// A Mammal has a name.
class Mammal(val name: String)</p>

<p>// A Dog is a Mammal that can bark.
class Dog(name: String) extends Mammal(name) {
  def bark(): Unit = println("bark!")
}</p>

<p>// A Cat is a Mammal that purrs.
class Cat(name: String) extends Mammal(name) {
  def purr(): Unit = println("purrrr")
}
```</p>

<h2>Invariance</h2>

<p>By default, generic classes are <em>invariant</em> on their parameter(s): whatever the relation between <code>A</code> and <code>B</code>, there
won't be any particular relationship between <code>List[A]</code> and <code>List[B]</code> - <code>B</code> could, for example, be a subclass of
<code>A</code>, but this would have no bearing on how <code>List[B]</code> relates to <code>List[A]</code>.</p>

<p><code>List</code> is a nice example in that it's a well known structure that's easy to reason about, but it's a bit cumbersome
when I wish to write actual code. Let's declare a simple <code>Wrapper</code> class, <em>invariant</em> in <code>A</code>:</p>

<p><code>scala
case class Wrapper[A](val a: A) {
  // Retrieves the wrapped value.
  def get = a
}
</code></p>

<p>Since <code>Wrapper</code> is <em>invariant</em> on its parameter, there is no relation between <code>Wrapper[Dog]</code> and <code>Wrapper[Mammal]</code>,
as shown in the following example:
```scala
// Does not compile: a Wrapper[Mammal] is not an instance of Wrapper[Dog]
val wd: Wrapper[Dog] = Wrapper(new Mammal("Flipper"))</p>

<p>// Does not compile: a Wrapper[Dog] is not an instance of Wrapper[Mammal].
val wm: Wrapper[Mammal] = Wrapper<a href="new%20Dog(" title="Lassie">Dog</a>)
```</p>

<p>That last one is a bit of a shame, though: since a <code>Dog</code> is a <code>Mammal</code>, surely a <code>Wrapper[Dog]</code> should be a
<code>Wrapper[Mammal]</code> as well? This is what <em>covariance</em> is.</p>

<h2>Covariance</h2>

<p>Saying that a class <code>C</code> is <em>covariant</em> on its parameter is saying that if <code>A</code> extends <code>B</code>, then <code>C[A]</code> extends <code>C[B]</code>.</p>

<p>In scala, making a class <em>covariant</em> on its parameter is achieved with the <code>+</code> modifier, as in the following example:</p>

<p><code>scala
case class Wrapper[+A](val a: A) {
  def get = a
}
</code></p>

<p>With <code>Wrapper</code> thus modified, our previous example works as expected:
```scala</p>

<p>// Does not compile: a Wrapper[Mammal] is not an instance of Wrapper[Dog]
val wd: Wrapper[Dog] = Wrapper(new Mammal("Flipper"))</p>

<p>// Now compiles: Wrapper is covariant, so a Wrapper[Dog] is a Wrapper[Mammal]
val wm: Wrapper[Mammal] = Wrapper<a href="new%20Dog(" title="Lassie">Dog</a>)
```</p>

<h2>Contravariance</h2>

<p><em>Contravariance</em> is the exact opposite of <em>covariance</em>: saying that a class <code>C</code> is <em>contravariant</em> on its parameter is
saying that if <code>A</code> extends <code>B</code>, then <code>C[B]</code> extends <code>C[A]</code>.</p>

<p>In scala, making a class <em>contravariant</em> on its parameter is achieved with the <code>-</code> modifier, as in the following
example:
<code>scala
trait Printer[-A] {
  // Prints its argument.
  // The reason why this method is named apply rather than, say, print will become clear later in this post.
  def apply(a: A)
}
</code></p>

<p>This is a bit counter intuitive, but makes sense in the case of classes used to <em>process</em> rather than <em>store</em> others:
```scala
// Note how this calls a method defined in Dog but not in Mammal.
class DogPrinter extends Printer[Dog] {
  override def apply(a: Dog) {</p>

<pre><code>println(a)
a.bark()
</code></pre>

<p>  }
}</p>

<p>// Since Printer is contravariant, an instance of MammalPrinter is a valid instance of Printer[Dog].
class MammalPrinter extends Printer[Mammal] {
  override def apply(a: Mammal) {</p>

<pre><code>println(a)
</code></pre>

<p>  }
}</p>

<p>// Compiles: a Printer[Mammal] is a valid Printer[Dog].
val wd: Printer[Dog] = new MammalPrinter()</p>

<p>// Does not compile: a Printer[Dog] is not a valid Printer[Mammal].
// If unsure why, consider what happens when DogPrinter calls the bark() method on an instance of Mammal.
val wm: Printer[Mammal] = new DogPrinter()
```</p>

<h2>Function variance</h2>

<p>Before explaining the compilation errors mentionned in the introduction of this post, we must take a closer look at
functions and how they vary on their parameters and return types.</p>

<p>In Scala, functions are instances. A unary function, for example, is an instance of <code>Function1[-T, +R]</code>, where <code>T</code> is
the type of the function's parameter and <code>R</code> that of its return value.</p>

<p>It's critical to understand why <code>Function1</code> is <em>contravariant</em> on its parameter type and <em>covariant</em> on its return
type: most of the complexity of type variance comes from that simple fact.</p>

<h3>Parameter type</h3>

<p>While this might not be obvious at a glance, we've already proven that a unary function was <em>contravariant</em> on its
parameter type.</p>

<p>The <code>Printer</code> trait we defined previously fulfills all the requirements of a unary function. We can in fact have it
extends <code>Function1[A, Unit]</code> without changing anything else in our previous code:
<code>scala
trait Printer[-A] extends Function1[A, Unit] {
  def apply(a: A): Unit
}
</code></p>

<p>The conclusion we previously reached on <code>Printer</code> still applies: it must be <em>contravariant</em> on <code>A</code>, which means that
a function is <em>contravariant</em> on its parameters.</p>

<h3>Return type</h3>

<p>By the same token, we've already proven that a function was <em>covariant</em> on its return type: our <code>Wrapper</code> class is
a valid <code>Function1[Unit, A]</code> and can be modified as follows without changing anything else:
<code>scala
case class Wrapper[+A](val a: A) extends Function1[Unit, A] {
  def apply(v: Unit): A = a
}
</code></p>

<p>The conclusion we previously reached on <code>Wrapper</code> still applies: it must be <em>covariant</em> on <code>A</code>, which means that
a function is <em>covariant</em> on its return type.</p>

<h2>Explanation of the compilation errors</h2>

<h3>Covariant in contravariant position</h3>

<p>We now have all the necessary keys to understand the dreaded
<code>covariant type A occurs in contravariant position in type A...</code> error message.</p>

<p>Let's first modify our <code>Wrapper</code> class to cause the issue:</p>

<p>```scala
case class Wrapper<a href="val%20a:%20A">+A</a> {
  def get: A = a</p>

<p>  // This method will cause a compilation error message.
  def set(va: A): Wrapper[A] = Wrapper(va)
}
```</p>

<p>Armed with our newfound type variance knowledge, this isn't actually so hard to understand: <code>Wrapper</code> is <em>covariant</em> on
<code>A</code> while <code>set</code> is <em>contravariant</em> on <code>A</code> (its parameter type), which is clearly an issue.</p>

<p>Luckily, Scala provides an easy work around through lower type bounds:
```scala
case class Wrapper<a href="val%20a:%20A">+A</a> {
  def get: A = a</p>

<p>  // Notice how the signature has changed.
  def set<a href="vb:%20B">B >: A</a>: Wrapper[B] = Wrapper(vb)
}
```</p>

<p>The <code>[B &gt;: A]</code> bit is telling Scala that a local type <code>B</code> has been declared, and that <code>B</code> must always be a superclass
of <code>A</code>.</p>

<p>With that modification, <code>set</code> is no longer <em>covariant</em> on <code>A</code>: its parameters are going to be of type <code>A</code> or something
more general, which respects the <em>contravariance</em> of a function's parameter type.</p>

<p>This is all a bit theoretical, so let's take a concrete example. Let's pretend that the Scala compiler accepts the
following code:</p>

<p><code>scala
case class Wrapper[+A](val a: A) {
  def get: A = a
  def set(va: A): Wrapper[A] = Wrapper(va)
}
</code></p>

<p>If this were to be considered correct, we'd be able to write the following:
```scala
class BorkedWrapper(i: Dog) extends Wrapper<a href="i">Dog</a> {
  override def set(vd: Dog): Wrapper[Dog] = {</p>

<pre><code>// Pay attention to the fact that we're calling bark(), that's the important bit.
vd.bark()
new BorkedWrapper(vd)
</code></pre>

<p>  }
}</p>

<p>// Wrapper is covariant on A, and Dog is a subtype of Mammal: an instance of Wrapper[Dog] is a legal instance of
// Wrapper[Mammal]. The following line is perfectly legal.
val wd: Wrapper[Mammal] = new BorkedWrapper(new Dog("Lassie"))</p>

<p>// A <code>Cat</code> is a legal instance of <code>Mammal</code>, there's nothing wrong with setting one to a Wrapper[Mammal]
wd.set(new Cat("Duchess"))
```</p>

<p>Scala just let us write code that calls the <code>bark</code> method of <code>Cat</code>, which is obviously impossible - that's where the
compilation error comes from. If were, however, to use lower type bounds, we'd find we can't provoque such a scenario
anymore:
```scala
case class Wrapper<a href="val%20a:%20A">+A</a> {
  def get: A = a
  def set<a href="vb:%20B">B >: A</a>: Wrapper[B] = Wrapper(vb)
}</p>

<p>// This class doesn't compile anymore: the set method doesn't actually overwrite Wrapper's, since they don't share
// parameter types. As an aside, that's as perfect an example of the benefit of explicitely writing override as I'm
// likely to find: not using it here would allow the code to compile, and figuring out that we're actually declaring
// two different set methods might take a while.
class BorkedWrapper(i: Dog) extends Wrapper<a href="i">Dog</a> {
  override def set(vd: Dog): Wrapper[Dog] = {</p>

<pre><code>vd.bark()
new BorkedWrapper(vd)
</code></pre>

<p>  }
}</p>

<p>// This doesn't compile either:
// - B doesn't have a bark method
// - new DogWrapper(vb) is not legal, since vb is not necessarily an instance of Dog.
class DogWrapper(d: Dog) extends Wrapper<a href="d">Dog</a> {
  override def set<a href="vb:%20B">B >: Dog</a>: Wrapper[B] = {</p>

<pre><code>vb.bark()
new DogWrapper(vb)
</code></pre>

<p>  }
}</p>

<p>val wd: Wrapper[Dog] = Wrapper(new Dog("Lassie"))</p>

<p>// This is now legal: Mammal is a superclass of Dog, so it can be passed to set.
// Note that the returned value is no longer an instance of Wrapper[Dog] but of Wrapper[Mammal].
val wm: Wrapper[Mammal] = wd.set(new Cat("Duchess"))
```</p>

<h3>Contravariant in covariant position</h3>

<p>There is of course a symmetrical issue for <em>contravariance</em>, which can be seen with the following code:
<code>scala
trait Printer[-A] {
   def apply(a: A): A
}
</code>
This causes the following compilation error:
<code>error: contravariant type A occurs in covariant position in type (a: A)A of method apply</code>.</p>

<p>Now that we have a good understanding of <em>contravariance</em>, <em>covariance</em> and how a function varies, this actually makes
sense: <code>Printer</code> is <em>contravariant</em> on <code>A</code> while <code>apply</code> is <em>covariant</em> on it (since <code>A</code> is <code>apply</code>'s return value).</p>

<p>We fix this the same way we did before, with type bounds - although this time we use an upper bound:
<code>scala
trait Printer[-A] {
   def apply[B &lt;: A](b: B): B
}
</code></p>

<p>I'd love to give a concrete example here, but I've failed to find a convincing one so far. I'll update this post if I
ever do.</p>

<h2>Mutable types and variance</h2>

<p>A last note about type variance: <em>contravariance</em> and <em>covariance</em> only work with immutable structures. Mutable ones
can be <em>invariant</em>, but they cannot be made anything else.</p>

<p>As a demonstration, let's try to make <code>Wrapper</code> mutable:
```scala
case class Wrapper<a href="private%20var%20a:%20A">+A</a> {
  def get: A = a</p>

<p>  // This won't work: a is an instance of A and cannot be used to store instances of B, since
  // B is necessarily a superclass of A.
  // The only way for this to work is to force B to be the same as A - which means making
  // Wrapper invariant.
  def set<a href="vb:%20B">B >: A</a>: Unit = a = vb
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pattern matching as parameter]]></title>
    <link href="http://nrinaudo.github.io/blog/2013/09/05/pattern-matching-as-parameter/"/>
    <updated>2013-09-05T17:25:00+02:00</updated>
    <id>http://nrinaudo.github.io/blog/2013/09/05/pattern-matching-as-parameter</id>
    <content type="html"><![CDATA[<p>Dear future self,</p>

<p>I just discovered a nice trick with pattern matching, which I thought I'd jot down before I forget about. It's a
logical consequence of what I wrote on <a href="/blog/2013/08/03/partial-functions/">partial functions</a>, but it just recently
clicked: a pattern match is a legal argument for higher-order functions expecting unary functions as parameters.</p>

<!-- more -->


<p>As I previously realised, pattern matching is a shortcut for partial function creation. Since partial functions are
unary, it follows that you can pass them to higher-order functions such as, for example, <code>map</code>:</p>

<p>```scala
// Unwraps the specified sequence, replacing None by the specified default value.
def badUnwrap<a href="la:%20Seq[Option[A]],%20da:%20A">A</a>: Seq[A] = la map {va =>
  va match {</p>

<pre><code>case Some(a) =&gt; a
case None    =&gt; da
</code></pre>

<p>  }
}</p>

<p>// This is doing exactly the same thing as badUnwrap, but takes advantage of the fact
// that one can pass a pattern match directly to to map. I believe it looks much cleaner.
def unwrap<a href="la:%20Seq[Option[A]],%20da:%20A">A</a>: Seq[A] = la map {
  case Some(a) => a
  case None    => da
}
```</p>

<p>It seems obvious in hinsight, but I'd never realised that before. My OCD is probably going to force me to go and "fix"
this in all the Scala code I ever wrote...</p>
]]></content>
  </entry>
  
</feed>
