<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: groovy | Dear Future Self]]></title>
  <link href="http://nrinaudo.github.io/blog/categories/groovy/atom.xml" rel="self"/>
  <link href="http://nrinaudo.github.io/"/>
  <updated>2014-01-03T14:58:29+01:00</updated>
  <id>http://nrinaudo.github.io/</id>
  <author>
    <name><![CDATA[Nicolas Rinaudo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using GPath with XmlSlurper]]></title>
    <link href="http://nrinaudo.github.io/blog/2013/04/09/using-gpath-with-xmlslurper/"/>
    <updated>2013-04-09T21:28:00+02:00</updated>
    <id>http://nrinaudo.github.io/blog/2013/04/09/using-gpath-with-xmlslurper</id>
    <content type="html"><![CDATA[<p>Dear future self,</p>

<p>Writing quick, discardable tools to parse some sort of XML, extract information from it and put it somewhere else is
something I have to do with some regularity.</p>

<p>The best tool I currently have for this is Groovy - it has access to the wealth of existing Java libraries, but with a
much more flexible syntax that does away with most of its parent's boilerplate.</p>

<p>Also, mostly, <code>XmlSlurper</code> and GPath. These make loading and extracting information from XML so smooth and easy that
one would almost forget the nightmare Java's internal XML APIs can be.</p>

<p>That's the theory, at least, but it doesn't appear to work for me. Whenever I have to use GPath, I find myself
stimmied by the same problems. Time and time again, I'll forget the difference between <code>grep</code> and <code>find</code>, or fail to
remember that detph- or breadth-first searches change the rules slightly.</p>

<p>Not anymore. Since my brain obviously has some sort of block as far as GPath syntax is concerned, this post will do in
its stead.</p>

<!-- more -->


<p>In the rest of this post, the <code>xml</code> object is assumed to have been obtained through one of <code>XmlSlurper</code>'s <code>parse</code>
methods.</p>

<h2>Finding an element by name</h2>

<p>The first things I <em>always</em> stumble on is when attempting to find all the elements of one type contained in an XML
document - say, for example, all <code>li</code> elements in an HTML file.</p>

<p>What I want to write is:
```groovy
xml.'**'.li.each {</p>

<pre><code>// processing code
</code></pre>

<p>}
```</p>

<p>And, for some reason, I <em>always</em> distinctly remember having done so in the past.</p>

<p>Well, future self, you're wrong. This syntax isn't supported, nor, as far as I can tell, has it ever been. Don't try to
get it to work.</p>

<p><code>**</code> is an alias for <code>depthFirst()</code>, which returns an iterator - a Groovy enhanced one, certainly, but still not one
that supports nested GPath expressions.</p>

<p>Here's what you want to do:</p>

<p>```groovy
xml.'**'.findAll {it.name() == 'li'}.each {</p>

<pre><code>// processing code
</code></pre>

<p>}
```</p>

<p>Pay attention to the way the element's name is retrieved: it's <code>it.name()</code>, not <code>it.name</code>. A method, not a property. And
yes, I know you feel vaguely insulted by what seems like such a stupid decision, but there's a very good reason for it:
properties describe children of the current node, so <code>it.name</code> would referrer to a <code>name</code> child element rather than the
element's name.</p>

<p>Honestly, if past me had told me that this morning, I'd have saved a good half hour this afternoon.</p>

<h2>grep VS find VS findAll</h2>

<p>These three methods have very similar contracts and purposes, but differ in ways that always do my head in.</p>

<p>I'll use the following input to illustrate these differences:
```xml
<html></p>

<pre><code>&lt;body&gt;
    &lt;ul&gt;
        &lt;li class="odd"&gt;&lt;span&gt;Element 1&lt;/span&gt;&lt;/li&gt;
        &lt;li class="even"&gt;&lt;span&gt;Element 2&lt;/span&gt;&lt;/li&gt;
        &lt;li class="odd"&gt;&lt;span&gt;Element 3&lt;/span&gt;&lt;/li&gt;
        &lt;li class="even"&gt;&lt;span&gt;Element 4&lt;/span&gt;&lt;/li&gt;
        &lt;li class="odd"&gt;&lt;span&gt;Element 5&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<h3>find</h3>

<p><code>find</code> is the simplest of the three: it returns the first node for which its closure argument returns <code>true</code>.</p>

<p>For example:
```groovy
// Finds the first li element with a class attribute of odd.
// Outputs 'Element 1'.
xml.body.ul.li.find {it.@class == 'odd'}.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
```</p>

<p>The returned value is an instance of <code>NodeChild</code>, which is convenient: you've just essentially obtained the root of a
sub-tree of your original XML document, and can treat it exactly as you did the <code>xml</code> object - by, for example, chaining additional GPath filters.</p>

<p>The following example is perfectly valid (and convenient):
```groovy
// Outputs 'Element 1'
xml.body.ul.li.find {it.@class == 'odd'}.span.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
```</p>

<p>Bear in mind that, once you've called <code>find</code>, you've restricted yourself to the <em>first</em> element that matched your
closure <em>only</em>. I'm sure normal people don't have a problem with that, but it seems to slip my mind very often.</p>

<h3>findAll</h3>

<p><code>findAll</code> is also fairly simple: it returns all nodes for which its closure argument returns <code>true</code>.</p>

<p>For example:
```groovy
// Finds all li elements with a class attribute of odd.
// Outputs 'Element 1\nElement 3\nElement 5\n'
xml.body.ul.li.findAll {it.@class == 'odd'}.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
```</p>

<p>The returned value is an instance of <code>FilteredNodeChildren</code>, a subclass of <code>GPathResult</code>, which <em>should</em> be nice but
looks... unfinished.</p>

<p>It basically supports the same nested GPath filters as <code>find</code>, with one very notable exception.
```groovy
// Does exactly what you'd expect: prints 'odd\nodd\nodd\n'
xml.body.ul.li.findAll {it.@class == 'odd'}.@class.each {println it.text()}</p>

<p>// Doesn't do what you'd expect at all: no span element is found.
xml.body.ul.li.findAll {it.@class == 'odd'}.span.each {println it.text()}
```</p>

<p>This has had me scratching my head for a while, but I can't find a reason why the <code>span</code> selector doesn't work. I'm not
confident enough in my Groovy skills to call this a bug in the standard APIs, but looking at the corresponding code, it
looks like it should work but doesn't.</p>

<p>The only solution I could find was to use the
<a href="http://groovy.codehaus.org/Operators#Operators-SpreadOperator">spread operator</a> as follows:
<code>groovy
// Outputs 'Element 1\nElement 3\nElement 5\n'
xml.body.ul.li.findAll {it.@class == 'odd'}*.span.each {println it.text()}
</code></p>

<p>While this works, I find it unsatisfactory: it looks out of place in what is an otherwise fairly clean GPath expression.
I'll keep looking and update this post should I find a reason, but for the moment, future self, bear in mind that
<code>findAll</code> feels a bit broken. You'd want its result to be manipulable in exactly the same way <code>find</code>'s result is, but
this is just not the case.</p>

<p><em>Edit: this is apparently a reported <a href="https://jira.codehaus.org/browse/GROOVY-6122">bug</a> and will hopefully be fixed
eventually</em></p>

<h3>grep</h3>

<p><code>grep</code> is where I usually get stuck. At a glance, its signature and purpose are the same as <code>findAll</code>'s.</p>

<p>For example:
```groovy
// Finds all li elements with a class attribute of odd.
// Outputs 'Element 1\nElement 3\nElement 5\n'
xml.body.ul.li.grep {it.@class == 'odd'}.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
```</p>

<p>There are, however, two differences between <code>findAll</code> and <code>grep</code>'s signatures.</p>

<p>The first one is that <code>grep</code>'s argument isn't a closure but an object whose <code>isCase(Object)</code> method will be evaluated.
You can pass in a closure, in which case the behaviour will be identical to that of <code>findAll</code>, but you could also pass
any object with a useful <code>isCase</code> method.</p>

<p>The second difference is in the return type: <code>ArrayList&lt;NodeChild&gt;</code>. Groovy collections have a fun if sometimes
misleading feature used to simplify calls to <code>collect</code>. The following calls are strictly equivalent:
```groovy
def set = ['foo', 'bar']</p>

<p>// Returns ['foo'.bytes, 'bar'.bytes]
set.collect {it.bytes}</p>

<p>// Does the same thing in a slightly more idiomatic way.
set.bytes
```</p>

<p>This means that the following code is perfectly correct, and will behave exactly as one would expect:
```groovy
xml.body.ul.li.grep {it.@class == 'odd'}.span.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
```</p>

<p>Which is brilliant, until you write the following:
```groovy
xml.body.ul.li.grep {it.@class == 'odd'}.'**'.findAll {it.name() == 'span'}.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
<code>
This, as it turns out, throws an exception that is frustrating to understand. So, future self, here's exactly what
happens laid out in simple terms:
</code>groovy
// 'nodes' is an ArrayList<NodeChild>
def nodes = xml.body.ul.li.grep {it.@class == 'odd'}</p>

<p>// This is strictly equivalent to nodes.collect {it.'<strong>'}.
// 'search' isn't an Iterator<NodeChild> but an ArrayList&lt;Iterator<NodeChild>>
def search = nodes.'</strong>'</p>

<p>// You'd expect 'it' to be a NodeChild, but you actually get an Iterator<NodeChild>.
// Iterators don't support the name() method, which is where the exception is raised.
search.findAll {it.name() == 'span'}.each {</p>

<pre><code>println it.text()
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
