<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Collections as type classes</title>
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link rel="stylesheet" type="text/css" href="../css/fontjolly.css" />
        <link rel="icon" type="image/png" href="../images/favicon.png">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Home</a>
                <a href="../archive.html">Archives</a>
            </div>
            <div id="navigation">
                <a title="GitHub" href="https://github.com/nrinaudo"><span class="ico-social-github"></span></a>
                <a title="Twitter" href="https://twitter.com/NicolasRinaudo"><span class="ico-social-twitter"></span></a>
                <a title="Stack Overflow" href="http://stackoverflow.com/users/1370349/nicolas-rinaudo"><span class="ico-line-chart"></span></a>
            </div>
        </div>

        <div id="content">
            <h1>Collections as type classes</h1>
<div class="info"><span class="date">2014-08-11</span><span class="tags"><a href="../tags/purely%20functional%20data%20structures.html" class="tag">purely functional data structures</a> | <a href="../tags/scala.html" class="tag">scala</a> | <a href="../tags/haskell.html" class="tag">haskell</a></span></div>
<p>I’ve been reading Chris Okasaki’s <a href="http://www.amazon.co.uk/gp/product/B00AKE1V04/ref=s9_simh_gw_p351_d3_i1?pf_rd_m=A3P5ROKL5A1OLE&amp;pf_rd_s=center-2&amp;pf_rd_r=02B6DPVTMCQXB84VAF5F&amp;pf_rd_t=101&amp;pf_rd_p=455344027&amp;pf_rd_i=468294">Purely Functional Data Structures</a> and implementing its various structures in Scala, which turns out to be surprisingly good fun.</p>
<p>I feel, however, that the object oriented approach taken by Scala for its collections is a bit constraining, and have been experimenting with a type class based approach instead.</p>
<!--more-->


<h2 id="rationale">Rationale</h2>
<p>Collection APIs are usually composed of various well known abstract data structures and their concrete implementations.</p>
<p>Abstract data structures do not define how things are implemented, but rather what operations they must support. A <code>Stack</code>, for example, is an abstract data structure that supports:</p>
<ul>
<li>checking whether it’s empty (<code>isEmpty</code>)</li>
<li>adding a value at its top (<code>push</code>)</li>
<li>reading the value at its top (<code>top</code>)</li>
<li>removing its top (<code>pop</code>)</li>
</ul>
<p>A variety of concrete data structures can support these operations - for the sake of argument, let’s use the functional list, with:</p>
<ul>
<li><code>Stack.isEmpty</code> <span class="math"> ⇔ </span> <code>List.isEmpty</code></li>
<li><code>Stack.push</code> <span class="math"> ⇔ </span> <code>List.::</code></li>
<li><code>Stack.top</code> <span class="math"> ⇔ </span> <code>List.head</code></li>
<li><code>Stack.pop()</code> <span class="math"> ⇔ </span> <code>List.tail</code></li>
</ul>
<p>There really is no reason to force <code>List</code> to be a <code>Stack</code> - stating that a list is a stack is not correct. It can be used as one, certainly, but the essence of a list is not being a stack.</p>
<p>There is in fact so little reason to define a list as a stack that, while the Scala standard library defines both data structures, there is no explicit relationship (that I could find) between the two.</p>
<p>On the other hand, as we’ve seen above, a list <em>can be used as</em> a stack: we should be able to write a type class that allows us to use arbitrary data structures, lists in particular, as stacks.</p>
<h2 id="functional-lists-as-something-like-a-stack">Functional lists as “something like a stack”</h2>
<p>We’re trying to write a bridge between concrete data structures and <code>Stack</code>: a type class that allows us to use arbitrary type as “something like a stack”. I’ll be referring to these as stack-like structures in the rest of this post.</p>
<p>In order to write such a type-class, we need to venture in the dark corners of the Scala type system and use higher-kinded types. This isn’t the topic of this post, however, so just think of higher-kinded types as types of types, just like higher-order functions are functions of functions.</p>
<p>Here’s how one could go about writing the contract for stack-like structures:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> scala.language.higherKinds

<span class="kw">trait</span> StackLike[<span class="dt">Impl[_]</span>] {
  <span class="co">// Checks whether the stack is empty.</span>
  <span class="kw">def</span> isEmpty[<span class="dt">A</span>](as: <span class="dt">Impl[A]</span>): <span class="dt">Boolean</span>

  <span class="co">// Pushes a value onto the stack.</span>
  <span class="kw">def</span> push[<span class="dt">A</span>](a: <span class="dt">A,</span> as: <span class="dt">Impl[A]</span>): <span class="dt">Impl[A]</span>

  <span class="co">// Returns the top of the stack.</span>
  <span class="kw">def</span> top[<span class="dt">A</span>](as: <span class="dt">Impl[A]</span>): <span class="dt">A</span>

  <span class="co">// Removes the top of the stack.</span>
  <span class="kw">def</span> pop[<span class="dt">A</span>](as: <span class="dt">Impl[A]</span>): <span class="dt">Impl[A]</span>
<span class="dt">}</span></code></pre>
<p>Don’t worry about the <code>Impl[_]</code> bit if you don’t understand it, it’s just Scala syntax for “<code>Impl</code> is a type constructor”. What <code>StackLike</code>’s type constraint is stating is that <code>StackLike</code> works on types that “contain” other types, without locking these other types down. This allows to create a <code>StackLike</code> implementation for <code>List</code>, for example, rather than for <code>List[Int]</code>.</p>
<p>Writing a <code>StackLike</code> implementation for <code>List</code> is straightforward:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">object</span> ListStack <span class="kw">extends</span> StackLike[<span class="dt">List</span>] {
  <span class="kw">override</span> <span class="kw">def</span> isEmpty[<span class="dt">A</span>](as: <span class="dt">List[A]</span>)    = as.<span class="fu">isEmpty</span>
  <span class="kw">override</span> <span class="kw">def</span> push[<span class="dt">A</span>](a: <span class="dt">A,</span> as: <span class="dt">List[A]</span>) = a :: <span class="dt">as</span>
  <span class="kw">override</span> <span class="kw">def</span> top[<span class="dt">A</span>](as: <span class="dt">List[A]</span>)        = as.<span class="fu">head</span>
  <span class="kw">override</span> <span class="kw">def</span> pop[<span class="dt">A</span>](as: <span class="dt">List[A]</span>)        = as.<span class="fu">tail</span>
}</code></pre>
<p>We’ve now created a type class for stack-like things, and an instance of that type class for lists. Let’s put it to use by writing safe <code>top</code> function:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> safeTop[<span class="dt">A, S[_]: StackLike</span>](stack: <span class="dt">S[A]</span>): <span class="dt">Option[A]</span> = {
  <span class="kw">val</span> stackLike = implicitly[<span class="dt">StackLike[S]</span>]

  <span class="kw">if</span>(stackLike.<span class="fu">isEmpty</span>(stack)) None
  <span class="kw">else</span>                         <span class="fu">Some</span>(stackLike.<span class="fu">top</span>(stack))
}

<span class="co">// Some(1)</span>
<span class="fu">safeTop</span>(<span class="fu">List</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>))

<span class="co">// None</span>
<span class="fu">safeTop</span>(<span class="fu">List</span>())</code></pre>
<p>Well, this works. It compiles and behaves as expected. It’s just… it wasn’t very pleasant to write, and probably isn’t very pleasant to read, either. The type constraint is nasty, and even though we’re trying to write purely functional code, Scala is also an object oriented language and I’d much rather write <code>stack.isEmpty</code> than <code>stackLike.isEmpty(stack)</code>.</p>
<h2 id="stack-like-structures-as-stacks">Stack-like structures as Stacks</h2>
<p>In order to write code such as <code>stack.isEmpty</code>, we first need to define a <code>Stack</code> trait. Here’s a possible definition:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Stack[<span class="dt">A</span>] {
  <span class="co">// Checks whether the stack is empty.</span>
  <span class="kw">def</span> isEmpty: <span class="dt">Boolean</span>

  <span class="co">// Pushes a value at the top of the stack.</span>
  <span class="kw">def</span> <span class="fu">push</span>(a: <span class="dt">A</span>): <span class="dt">Stack[A]</span>

  <span class="co">// Returns the value at the top of the stack.</span>
  <span class="kw">def</span> top: <span class="dt">A</span>

  <span class="co">// Removes the value at the top of the stack.</span>
  <span class="kw">def</span> <span class="fu">pop</span>(): <span class="dt">Stack[A]</span>
<span class="dt">}</span></code></pre>
<p>We now have a trait that defines what a stack is, and another that allows us to treat arbitrary data structures as stack-like ones. All we need is a simple way to go from one to the other, which sounds like a perfect job for Scala’s implicit conversion mechanism:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">class</span> Wrapped[<span class="dt">A, Impl[_] : StackLike</span>](stack: <span class="dt">Impl[A]</span>) <span class="kw">extends</span> Stack[<span class="dt">A</span>] {
  <span class="kw">private</span> <span class="kw">lazy</span> <span class="kw">val</span> stackLike = implicitly[<span class="dt">StackLike[Impl]</span>]

  <span class="kw">override</span> <span class="kw">def</span> isEmpty    = stackLike.<span class="fu">isEmpty</span>(stack)
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">push</span>(a: <span class="dt">A</span>) = <span class="kw">new</span> <span class="fu">Wrapped</span>(stackLike.<span class="fu">push</span>(a, stack))
  <span class="kw">override</span> <span class="kw">def</span> top        = stackLike.<span class="fu">top</span>(stack)
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">pop</span>()      = <span class="kw">new</span> <span class="fu">Wrapped</span>(stackLike.<span class="fu">pop</span>(stack))
}</code></pre>
<p>Having an implicit conversion from objects that have an implicit <code>StackLike</code> implementation to instances of <code>Stack</code>, we can rewrite our <code>safeTop</code> function in a much more pleasant way:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> safeTop[<span class="dt">A</span>](stack: <span class="dt">Stack[A]</span>): <span class="dt">Option[A]</span> = {
  <span class="kw">if</span>(stack.<span class="fu">isEmpty</span>) None
  <span class="kw">else</span>              <span class="fu">Some</span>(stack.<span class="fu">top</span>)
}

<span class="co">// Some(1)</span>
<span class="fu">safeTop</span>(<span class="fu">List</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>))

<span class="co">// None</span>
<span class="fu">safeTop</span>(<span class="fu">List</span>())</code></pre>
<p>The Scala compiler will realise that <code>safeTop(List(1, 2, 3, 4, 5))</code> does not type check: an instance of <code>List</code> is not an instance of <code>Stack</code>. It’ll then look into the various implicit conversions in scope to find if there’s exactly one that could allow it to transform a <code>List</code> into a <code>Stack</code>, and <code>Wrapped</code> looks like it might work. It just requires an implicit <code>StackLike</code> implementation for <code>List</code> to be in scope, which there is: <code>ListStack</code>.</p>
<p>This allows us to pass instances of <code>List</code> where instances of <code>Stack</code> are expected, and for the Scala compiler to do all the work of turning the former into the later for us.</p>
<h2 id="a-haskell-stack">A Haskell stack</h2>
<p>While I love Scala, and I’m turning into a big fan of type classes, I have to admit that Haskell does it rather better. We do not need to go through the <code>StackLike</code> and implicit conversion mechanism, and can directly define <code>Stack</code> as a type class:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Stack</span> f <span class="kw">where</span>
  <span class="co">-- Returns an empty stack.</span>
<span class="ot">  empty ::</span> f a

  <span class="co">-- Checks whether the stack is empty.</span>
<span class="ot">  isEmpty ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Bool</span>

  <span class="co">-- Pushes an value onto the stack.</span>
<span class="ot">  push ::</span> a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a

  <span class="co">-- Returns the top of the stack.</span>
<span class="ot">  top ::</span> f a <span class="ot">-&gt;</span> a

  <span class="co">-- Removes the top of the stack.</span>
<span class="ot">  pop ::</span> f a <span class="ot">-&gt;</span> f a</code></pre>
<p>Note that, just as in Scala, <code>Stack</code> is a higher-kinded type: <code>f</code> is a type constructor, as is evident in the <code>empty :: f a</code> type signature, for example.</p>
<p>Writing an instance of <code>Stack</code> for lists is straightforward:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Stack</span> [] <span class="kw">where</span>
  empty   <span class="fu">=</span> []
  isEmpty <span class="fu">=</span> null
  push    <span class="fu">=</span> (<span class="fu">:</span>)
  top     <span class="fu">=</span> head
  pop     <span class="fu">=</span> tail</code></pre>
<p>And that’s all we need. Provided <code>Stack</code> and the list instance of <code>Stack</code> are in scope, it’s now perfectly legal to pass a list wherever a stack is required. No implicit convertion, no <code>Wrapper</code> object to appease the type system.</p>
<p>This is how we’d write our <code>safeTop</code> function in Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">safeTop ::</span> (<span class="dt">Stack</span> s) <span class="ot">=&gt;</span> s a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
safeTop s
  <span class="fu">|</span> isEmpty s <span class="fu">=</span> <span class="dt">Nothing</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> top s

<span class="co">-- Just 1</span>
safeTop [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]

<span class="co">-- Nothing</span>
safeTop []</code></pre>
<p>The end result is pretty much the same, and <code>safeTop</code> is implemented as easily in Scala as it is in Haskell.</p>
<p>It seems possible to get the same result in both languages, but Scala required us to jump through quite a few more hoops to get there. Do note, however, that even though we had to do more work in the <em>library</em> part of our implementation, the problem is sorted once and for all and users of our <code>Stack</code> abstract data structure only ever have to worry about writting an instance of <code>StackLike</code>, which is relatively straightforward.</p>

        </div>
    </body>
</html>
