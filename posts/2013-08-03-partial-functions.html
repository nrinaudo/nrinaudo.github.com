<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Partial Functions</title>
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link rel="stylesheet" type="text/css" href="../css/fontjolly.css" />
        <link rel="icon" type="image/png" href="../images/favicon.png">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Home</a>
                <a href="../archive.html">Archives</a>
            </div>
            <div id="navigation">
                <a title="GitHub" href="https://github.com/nrinaudo"><span class="ico-social-github"></span></a>
                <a title="Twitter" href="https://twitter.com/NicolasRinaudo"><span class="ico-social-twitter"></span></a>
                <a title="Stack Overflow" href="http://stackoverflow.com/users/1370349/nicolas-rinaudo"><span class="ico-line-chart"></span></a>
            </div>
        </div>

        <div id="content">
            <h1>Partial Functions</h1>
<div class="info"><span class="date">2013-08-03</span><span class="tags"><a href="../tags/scala.html" class="tag">scala</a></span></div>
<p>Partial functions are something that many (beginner) Scala developers are not aware of. Once you know of them however, you realise that Scala uses them <em>everywhere</em>, and that they can be terribly convenient.</p>
<!--more-->

<h2 id="origin-of-the-name">Origin of the name</h2>
<p>From what I’ve been able to find, partial functions are originally a mathematical concept. A partial function is one that is only defined for a subset of its domain (as opposed to a <em>total</em> function, which is defined for the entirety of its domain).</p>
<p>For example, the square root functions is total over <span class="math">N</span>, but partial over <span class="math">Z</span>.</p>
<h2 id="partial-functions-in-scala">Partial functions in Scala</h2>
<p>Scala’s partial function are exactly the same as their mathematical counterparts: they’re only defined for a subset of their domain.</p>
<p>In practical terms, a partial function is an instance of <code>PartialFunction</code>, which is roughly an instance of <code>Function1</code> with an added <code>isDefinedAt</code> method whose purpose is to let callers know whether the function is defined for a particular value.</p>
<p>One could write a partial version of <code>math.sqrt</code> as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> sqrt = <span class="kw">new</span> PartialFunction[<span class="dt">Int, Double</span>] {
  <span class="co">// sqrt is only defined for positive numbers.</span>
  <span class="kw">def</span> <span class="fu">isDefinedAt</span>(p: <span class="dt">Int</span>) = p &gt;= <span class="dv">0</span>

  <span class="co">// Should this be called on a negative number, a MatchError would be thrown.</span>
  <span class="kw">def</span> <span class="fu">apply</span>(p: <span class="dt">Int</span>) = p <span class="kw">match</span> {
    <span class="kw">case</span> a <span class="kw">if</span> a &gt;= <span class="dv">0</span> =&gt; math.<span class="fu">sqrt</span>(a)
  }
}</code></pre>
<p>That’s rather a lot of code to write for something that simple, though. As usual, Scala has dedicated syntax to make this much easier to write: <code>case</code> statements.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// This is strictly equivalent to our previous example, but with much less boilerplate.</span>
<span class="co">// Note that a partial function's type cannot be inferred and needs always be fully declared.</span>
<span class="kw">val</span> sqrt: <span class="dt">PartialFunction[Int, Double]</span> = {
  <span class="kw">case</span> p <span class="kw">if</span> p &gt;= <span class="dv">0</span> =&gt; math.<span class="fu">sqrt</span>(p)
}

<span class="co">// Prints 'true'</span>
<span class="fu">println</span>(sqrt.<span class="fu">isDefinedAt</span>(<span class="dv">4</span>))

<span class="co">// Prints '2.0'</span>
<span class="fu">println</span>(<span class="fu">sqrt</span>(<span class="dv">4</span>))

<span class="co">// Prints 'false'</span>
<span class="fu">println</span>(sqrt.<span class="fu">isDefinedAt</span>(-<span class="dv">4</span>))

<span class="co">// Throws a MatchError</span>
<span class="fu">println</span>(<span class="fu">sqrt</span>(-<span class="dv">4</span>))</code></pre>
<h2 id="collecting-values-through-partial-functions">Collecting values through partial functions</h2>
<p>Partial functions are very handy for classes that support the <code>collect</code> method, which acts as a combined <code>map</code> and <code>filter</code>:</p>
<ul>
<li>any value for which the partial function isn’t defined is filtered out</li>
<li>all other values are replaced by the return value of the partial function</li>
</ul>
<p>For example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> sqrt: <span class="dt">PartialFunction[Int, Double]</span> = {
  <span class="kw">case</span> p <span class="kw">if</span> p &gt;= <span class="dv">0</span> =&gt; math.<span class="fu">sqrt</span>(p)
}

<span class="kw">val</span> n = <span class="fu">List</span>(<span class="dv">4</span>, -<span class="dv">4</span>, <span class="dv">9</span>, -<span class="dv">9</span>, <span class="dv">16</span>, -<span class="dv">16</span>)

<span class="co">// Prints 'List(2.0, 3.0, 4.0)'</span>
<span class="fu">println</span>(n collect sqrt)</code></pre>
<p>As an aside, a <code>Seq</code> is an implementation of <code>PartialFunction</code>, which has the odd side-effect of allowing us to write the following:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> from    = <span class="fu">List</span>(<span class="dv">4</span>, -<span class="dv">4</span>, <span class="dv">9</span>, -<span class="dv">9</span>, <span class="dv">16</span>, -<span class="dv">16</span>)
<span class="kw">val</span> indexes = <span class="fu">List</span>(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">4</span>)

<span class="co">// For each value x of indexes such that from(x) is defined, collect from(x).</span>
<span class="co">// Or, in plain english, extracts the values of from found at the values defined in indexes.</span>
<span class="co">// This prints 'List(4, 9, 16)'</span>
<span class="fu">println</span>(indexes collect from)</code></pre>
<h2 id="chaining-partial-functions">Chaining partial functions</h2>
<p>Another interesting feature of partial function is that they can be chained together through their <code>orElse</code> method, which is very similar to, and complements nicely, <code>andThen</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Multiplies all odd values by 2.</span>
<span class="kw">val</span> times2: <span class="dt">PartialFunction[Int, Int]</span> = {
  <span class="kw">case</span> p: <span class="dt">Int</span> <span class="kw">if</span> p % <span class="dv">2</span> == <span class="dv">1</span> =&gt; p * <span class="dv">2</span>
}

<span class="co">// Adds 1 to all even values.</span>
<span class="kw">val</span> plus1: <span class="dt">PartialFunction[Int, Int]</span> = {
  <span class="kw">case</span> p: <span class="dt">Int</span> <span class="kw">if</span> p % <span class="dv">2</span> == <span class="dv">0</span> =&gt; p + <span class="dv">1</span>
}

<span class="co">// This will call times2 for all odd values and plus1 for all even ones.</span>
<span class="kw">val</span> chained = times2 orElse plus1

<span class="co">// Prints 'List(2, 3, 6, 5, 10, 7)'</span>
<span class="fu">println</span>(<span class="fu">List</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>) collect chained)</code></pre>
<h2 id="lifting-partial-functions">Lifting partial functions</h2>
<p>Finally, Scala makes it easy to turn a partial function into a total one that returns instances of <code>Option</code> and vice-versa through <code>PartialFunction.lift</code> and <code>Function.unlift</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> sqrt: <span class="dt">PartialFunction[Int, Double]</span> = {
  <span class="kw">case</span> p: <span class="dt">Int</span> <span class="kw">if</span> p &gt;= <span class="dv">0</span> =&gt; math.<span class="fu">sqrt</span>(p)
}

<span class="co">// sqrt throws MatchErrors for negative values. safeSqrt, on the other hand, returns None.</span>
<span class="kw">val</span> safeSqrt = sqrt.<span class="fu">lift</span>

<span class="co">// Prints 'Some(2.0)'</span>
<span class="fu">println</span>(<span class="fu">safeSqrt</span>(<span class="dv">4</span>))

<span class="co">// Prints 'None'</span>
<span class="fu">println</span>(<span class="fu">safeSqrt</span>(-<span class="dv">4</span>))


<span class="co">// unlift does the opposite operation:</span>
<span class="kw">val</span> unsafeSqrt = Function.<span class="fu">unlift</span>(safeSqrt)

<span class="co">// Prints '2.0'</span>
<span class="fu">println</span>(<span class="fu">unsafeSqrt</span>(<span class="dv">4</span>))

<span class="co">// Throws a MatchError</span>
<span class="fu">println</span>(<span class="fu">unsafeSqrt</span>(-<span class="dv">4</span>))</code></pre>

        </div>
    </body>
</html>
