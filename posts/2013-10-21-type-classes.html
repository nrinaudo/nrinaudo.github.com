<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Type classes</title>
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link rel="stylesheet" type="text/css" href="../css/fontjolly.css" />
        <link rel="icon" type="image/png" href="../images/favicon.png">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Home</a>
                <a href="../archive.html">Archives</a>
            </div>
            <div id="navigation">
                <a title="GitHub" href="https://github.com/nrinaudo"><span class="ico-social-github"></span></a>
                <a title="Twitter" href="https://twitter.com/NicolasRinaudo"><span class="ico-social-twitter"></span></a>
                <a title="Stack Overflow" href="http://stackoverflow.com/users/1370349/nicolas-rinaudo"><span class="ico-line-chart"></span></a>
            </div>
        </div>

        <div id="content">
            <h1>Type classes</h1>
<div class="info"><span class="date">2013-10-21</span><span class="tags"><a href="../tags/scala.html" class="tag">scala</a></span></div>
<p><em>Type classes</em> were an entirely new concept to me when I first discovered them in Scala. Now that (I think) I understand them, however, they completely changed the way I think about code, inheritance and modularity.</p>
<!--more-->

<h2 id="purpose">Purpose</h2>
<p>Type classes are a form of polymorphism used to describe a set of features a class can have, without implementing them directly in the class. Where subtype polymorphism (inheritance) describes an <em>is a</em> relation, type classes describe a <em>can be used as</em> one.</p>
<p>This is a bit abstract, so let’s take a concrete example. Say that you’re using an external library that exposes a <code>Person</code> class, implemented as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Person</span>(first: <span class="dt">String,</span> last: <span class="dt">String</span>) {
  <span class="kw">override</span> <span class="kw">def</span> toString = <span class="st">&quot;%s %s&quot;</span> <span class="fu">format</span> (first, last)
}</code></pre>
<p>Your application holds a <code>List[Person]</code> instance, and needs to sort it alphabetically by last name - for printing purposes, say. The usual OO solution is to have <code>Person</code> extend <a href="http://www.scala-lang.org/api/current/index.html#scala.math.Ordered">Ordered</a>, but in our case, the library author didn’t think of doing that.</p>
<p>You still have a few options, such as creating an ordered wrapper for <code>Person</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">class</span> <span class="fu">OrderedPerson</span>(<span class="kw">val</span> wrapped: <span class="dt">Person</span>) <span class="kw">extends</span> AnyVal <span class="kw">with</span> Ordered[<span class="dt">OrderedPerson</span>] {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">compare</span>(that: <span class="dt">OrderedPerson</span>): <span class="dt">Int</span> = wrapped.<span class="fu">last</span>.<span class="fu">compareTo</span>(that.<span class="fu">wrapped</span>.<span class="fu">last</span>)
}</code></pre>
<p>That’s still not entirely satisfactory, however: a <code>List[Person]</code> is not a <code>List[OrderedPerson]</code>, and sorting your list still requires a bit of legwork:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">list.<span class="fu">map</span>(<span class="kw">new</span> <span class="fu">OrderedPerson</span>(_)).<span class="fu">sorted</span>.<span class="fu">map</span>(_.<span class="fu">wrapped</span>)</code></pre>
<p>It’s not a huge amount of work, but you still need to transform every single entry from a <code>Person</code> to an <code>OrderedPerson</code> and back. I also think that having to do it explicitly prevents the Scala compiler from the usual <code>AnyVal</code> inlining optimisations, but might be mistaken.</p>
<p>The problem becomes a bit worse if you need to support multiple sort orders - reverse alphabetical order, say, or alphabetical on the first name rather than the last one: in addition of having to implement a wrapper class for each of these sort orders, you need to change the way your list is transformed up to and back from each.</p>
<p>The other solution is to use the <a href="http://www.scala-lang.org/api/current/index.html#scala.math.Ordering">Ordering</a> trait as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">object</span> LastNameOrdering <span class="kw">extends</span> Ordering[<span class="dt">Person</span>] {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">compare</span>(a: <span class="dt">Person,</span> b: <span class="dt">Person</span>): <span class="dt">Int</span> = a.<span class="fu">last</span>.<span class="fu">compareTo</span>(b.<span class="fu">last</span>)
}</code></pre>
<p>Since <code>List.sorted</code> takes an <code>Ordering</code> parameter, you can now sort your list as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">list.<span class="fu">sorted</span>(LastNameOrdering)</code></pre>
<p>Better yet, since both this parameter and <code>LastNameOrdering</code> are declared implicit, you can simply bring <code>LastNameOrdering</code> in scope and write:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">list.<span class="fu">sorted</span></code></pre>
<p>Supporting multiple sort orders is done by having an implementation of <code>Ordering[Person]</code> for each and passing the correct one to <code>list.sorted</code>, either implicitly or explicitly.</p>
<p><code>Ordering</code> is an example of type class: <code>Person</code> is not ordered, but it can be used as something that has an order, and this is materialized by the <code>LastNameOrdering</code> type class instance.</p>
<p>It’s also important to note that, using this mechanism, we’ve just augmented <code>Person</code>, a final class, with features it did not have to begin with, and we’ve do so without modifying or recompiling it, or without wrapping it into adapter classes.</p>
<p>Another important insight is that thanks to this mechanism, as long as something can conceivably be ordered, we’ll be able to sort a list of it. The sorting problem is dealt with once and for all, and for all possible types of data.</p>
<h2 id="writing-a-type-class">Writing a type class</h2>
<p>We now have a better understanding of what a type class is. Implementing one requires surprisingly little code and, thanks to Scala’s support of implicit parameters, can be made all but invisible to callers.</p>
<p>Let’s say that our application requires a facility for printing <code>Person</code> to <code>stdout</code>. A naive first implementation could be:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Printer {
  <span class="kw">def</span> <span class="fu">print</span>(p: <span class="dt">Person</span>) = <span class="fu">println</span>(p)
}</code></pre>
<p>This works, but is very limiting:</p>
<ul>
<li>the only supported output format is that of <code>toString</code>, and we’d need to write adapter classes for each format we want to add (JSON, say, or locale dependant formats).</li>
<li>it only works for <code>Person</code> - what if we have another <code>Company</code> class that we’d like to print to stdout as well? Do we need to write an entirely different printing facility for that?</li>
</ul>
<p>This is were type classes really shine. Instead of letting the object being printed decide how to format itself, we create a trait and delegate that responsability to it:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Used solely for the purpose of formatting instances of A.</span>
<span class="kw">trait</span> Show[<span class="dt">A</span>] {
  <span class="kw">def</span> <span class="fu">show</span>(a: <span class="dt">A</span>): <span class="dt">String</span>
<span class="dt">}</span>

<span class="dt">object</span> Printer {
  <span class="co">// Now accepts two parameters: an object to print, and an object that knows how to format it.</span>
  <span class="kw">def</span> print[<span class="dt">A</span>](a: <span class="dt">A,</span> f: <span class="dt">Show[A]</span>) = <span class="fu">println</span>(f.<span class="fu">show</span>(a))
}

<span class="co">// Person specific formatter.</span>
<span class="kw">object</span> PersonShow <span class="kw">extends</span> Show[<span class="dt">Person</span>] {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">show</span>(a: <span class="dt">Person</span>) = a.<span class="fu">last</span>
}

<span class="co">// We've now entirely de-coupled Person and its formatting mechanism.</span>
Printer.<span class="fu">print</span>(<span class="kw">new</span> <span class="fu">Person</span>(<span class="st">&quot;Robert&quot;</span>, <span class="st">&quot;Smith&quot;</span>), PersonShow)</code></pre>
<p>This is nice but a bit verbose: we still need to explicitly pass <code>PersonShow</code> around. As usual, Scala has mechanisms to reduce the verbosity: implicit parameters.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Printer {
  <span class="co">// The formatter is now an implicit parameter.</span>
  <span class="kw">def</span> print[<span class="dt">A</span>](a: <span class="dt">A</span>)(<span class="kw">implicit</span> f: <span class="dt">Show[A]</span>) = <span class="fu">println</span>(f.<span class="fu">show</span>(a))
}

<span class="co">// Declares an implicit Show[Person] in scope.</span>
<span class="kw">implicit</span> <span class="kw">object</span> PersonShow <span class="kw">extends</span> Show[<span class="dt">Person</span>] {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">show</span>(a: <span class="dt">Person</span>) = a.<span class="fu">last</span>
}

<span class="co">// We can now omit the formatter entirely.</span>
Printer.<span class="fu">print</span>(<span class="kw">new</span> <span class="fu">Person</span>(<span class="st">&quot;Robert&quot;</span>, <span class="st">&quot;Smith&quot;</span>))</code></pre>
<p>From Scala 2.8 onwards, the same can be achieved through context bounds:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Printer {
  <span class="co">// [A: Show] should be read as &quot;A such that there exists an implicit Show[A] in scope&quot;</span>
  <span class="kw">def</span> print[<span class="dt">A: Show</span>](a: <span class="dt">A</span>) = <span class="fu">println</span>(implicitly[<span class="dt">Show[A]</span>].<span class="fu">show</span>(a))
}</code></pre>
<p>Not only have we added a new formatting feature to <code>Person</code> without modifying its source code or extending it, but we’ve also done it for all possible classes. Nothing in our implementation ties us to <code>Person</code>: adding support for, say, dates, is simply done by writing a <code>Show</code> implementation for <code>Date</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> java.util.Date

<span class="co">// Formats dates as legal ISO 8601 strings.</span>
<span class="kw">implicit</span> <span class="kw">object</span> Show <span class="kw">extends</span> Show[<span class="dt">Date</span>] {
  <span class="co">// For demonstration purposes only, do *not* duplicate this: SimpleDateFormat is not thread safe.</span>
  <span class="kw">private</span> <span class="kw">val</span> formatter = <span class="kw">new</span> java.<span class="fu">text</span>.<span class="fu">SimpleDateFormat</span>(<span class="st">&quot;yyyy-MM-dd'T'HH:mm:ssz&quot;</span>)
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">show</span>(date: <span class="dt">Date</span>) = formatter<span class="fu">.format</span>(date)
}

<span class="co">// Since DateShow is both implicit and in scope, there's no need to pass it explicitly.</span>
Printer.<span class="fu">print</span>(<span class="kw">new</span> <span class="fu">Date</span>())</code></pre>

        </div>
    </body>
</html>
