<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Implementing equals in Scala</title>
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link rel="stylesheet" type="text/css" href="../css/fontjolly.css" />
        <link rel="icon" type="image/png" href="../images/favicon.png">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Home</a>
                <a href="../archive.html">Archives</a>
            </div>
            <div id="navigation">
                <a title="GitHub" href="https://github.com/nrinaudo"><span class="ico-social-github"></span></a>
                <a title="Twitter" href="https://twitter.com/NicolasRinaudo"><span class="ico-social-twitter"></span></a>
                <a title="Stack Overflow" href="http://stackoverflow.com/users/1370349/nicolas-rinaudo"><span class="ico-line-chart"></span></a>
            </div>
        </div>

        <div id="content">
            <h1>Implementing equals in Scala</h1>
<div class="info"><span class="date">2013-06-20</span><span class="tags"><a href="../tags/scala.html" class="tag">scala</a></span></div>
<p>Writing proper <code>equals</code> methods in Java is <a href="http://stackoverflow.com/questions/27581/overriding-equals-and-hashcode-in-java">a bit of a pain</a>. Turns out, Scala is slightly better but still somewhat cumbersome. It’s mostly a matter of remembering all the rules.</p>
<!--more-->

<h2 id="basic-implementation">Basic implementation</h2>
<p>Pattern matching makes a basic implementation of <code>equals</code> rather easy to read and write:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> <span class="fu">Point2d</span>(<span class="kw">val</span> x: <span class="dt">Int,</span> <span class="kw">val</span> y: <span class="dt">Int</span>) {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">equals</span>(other: <span class="dt">Any</span>) = other <span class="kw">match</span> {
    <span class="co">// Any instance of Point2d with the same x and y as the current instance is equal to it.</span>
    <span class="kw">case</span> o: <span class="dt">Point2d =&gt; o.x</span> == x &amp;&amp; o.<span class="fu">y</span> == y
    <span class="co">// Anything else isn't.</span>
    <span class="kw">case</span> _          =&gt; <span class="kw">false</span>
  }
}</code></pre>
<h2 id="hashcode">hashCode</h2>
<p>Exactly as in Java, overriding <code>equals</code> should always be accompanied by an equivalent implementation of <code>hashCode</code>.</p>
<p>Nothing tricky there, although the convention is slightly different than in Java: Scala uses the 41 magic number where Java uses 31.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> <span class="fu">Point2d</span>(<span class="kw">val</span> x: <span class="dt">Int,</span> <span class="kw">val</span> y: <span class="dt">Int</span>) {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">hashCode</span>() = <span class="dv">41</span> * (<span class="dv">41</span> + x) + y

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">equals</span>(other: <span class="dt">Any</span>) = other <span class="kw">match</span> {
    <span class="kw">case</span> o: <span class="dt">Point2d =&gt; o.x</span> == x &amp;&amp; o.<span class="fu">y</span> == y
    <span class="kw">case</span> _          =&gt; <span class="kw">false</span>
  }
}</code></pre>
<h2 id="canequal">canEqual</h2>
<p>This is where Scala becomes more cumbersome (yet more powerful) than Java.</p>
<p>A proper <code>equals</code> method should be reflexive, which means that <code>x == y</code> implies that <code>y == x</code>. Common Java wisdom has it that to enforce this, instances of a subclass cannot be equal to instances of their parent class.</p>
<p>Say, for example, that we created a <code>Point3d</code> class with a <code>z</code> coordinate. Instances of <code>Point3d</code> cannot be equal to instances of <code>Point2d</code>, which means that instances of <code>Point2d</code> cannot be equal to instances of <code>Point3d</code>.</p>
<p>This restriction can be a bit too strict: sometimes, a class subclasses another without changing the meaning of instance equality. In order to deal with this cases, Scala uses the <code>Equals</code> trait:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> <span class="fu">Point2d</span>(<span class="kw">val</span> x: <span class="dt">Int,</span> <span class="kw">val</span> y: <span class="dt">Int</span>) <span class="kw">extends</span> Equals {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">hashCode</span>() = <span class="dv">41</span> * (<span class="dv">41</span> + x) + y

  <span class="co">// Anything that is an instance of `Point2d` can be equal to it.</span>
  <span class="kw">def</span> <span class="fu">canEqual</span>(that: <span class="dt">Any</span>) = that.<span class="fu">isInstanceOf</span>[<span class="dt">Point2d</span>]

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">equals</span>(other: <span class="dt">Any</span>) = other <span class="kw">match</span> {
    <span class="co">// Note the call to canEqual which makes sure that other is ok to be compared with this.</span>
    <span class="co">// In our example, other would be an instance of Point3d and would refuse the comparison.</span>
    <span class="kw">case</span> o: <span class="dt">Point2d =&gt; (o</span> canEqual <span class="kw">this</span>) &amp;&amp; o.<span class="fu">x</span> == x &amp;&amp; o.<span class="fu">y</span> == y
    <span class="kw">case</span> _          =&gt; <span class="kw">false</span>
  }
}

<span class="kw">class</span> <span class="fu">CustomPoint</span>(x: <span class="dt">Int,</span> y: <span class="dt">Int</span>) <span class="kw">extends</span> <span class="fu">Point2d</span>(x, y) {
  <span class="co">// custom code.</span>
}

<span class="co">// CustomPoint doesn't override canEqual, which means that it's perfectly possible for an instance of Point2d and</span>
<span class="co">// CustomPoint to be equal. And Indeed:</span>

<span class="co">// Prints true</span>
<span class="fu">println</span>(<span class="kw">new</span> <span class="fu">Point2d</span>(<span class="dv">1</span>, <span class="dv">2</span>) == <span class="kw">new</span> <span class="fu">CustomPoint</span>(<span class="dv">1</span>, <span class="dv">2</span>))
<span class="co">// Prints true</span>
<span class="fu">println</span>(<span class="kw">new</span> <span class="fu">CustomPoint</span>(<span class="dv">1</span>, <span class="dv">2</span>) == <span class="kw">new</span> <span class="fu">Point2d</span>(<span class="dv">1</span>, <span class="dv">2</span>))


<span class="co">// Point3d adds a new field, which makes it impossible for an instance of Point2d and Point3d to be equal.</span>
<span class="kw">class</span> <span class="fu">Point3d</span>(x: <span class="dt">Int,</span> y: <span class="dt">Int,</span> <span class="kw">val</span> z: <span class="dt">Int</span>) <span class="kw">extends</span> <span class="fu">Point2d</span>(x, y) {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">hashCode</span>() = <span class="dv">41</span> * (<span class="dv">41</span> + <span class="kw">super</span>.<span class="fu">hashCode</span>) + z

  <span class="co">// This will cause the equals method of Point2d to return false.</span>
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">canEqual</span>(that: <span class="dt">Any</span>) = that.<span class="fu">isInstanceOf</span>[<span class="dt">Point3d</span>]

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">equals</span>(other: <span class="dt">Any</span>) = other <span class="kw">match</span> {
    <span class="kw">case</span> o:Point3d =&gt; (o canEqual <span class="kw">this</span>) &amp;&amp; z == o.<span class="fu">z</span> &amp;&amp; <span class="kw">super</span>.<span class="fu">equals</span>(o)
    <span class="kw">case</span> _         =&gt; <span class="kw">false</span>
  }
}

<span class="co">// Point3d overrides canEqual, which makes it impossible for it to be equal to instances of Point2d. And indeed:</span>

<span class="co">// Prints false</span>
<span class="fu">println</span>(<span class="kw">new</span> <span class="fu">Point2d</span>(<span class="dv">1</span>, <span class="dv">2</span>) == <span class="kw">new</span> <span class="fu">Point3d</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>))
<span class="co">// Prints false</span>
<span class="fu">println</span>(<span class="kw">new</span> <span class="fu">Point3d</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>) == <span class="kw">new</span> <span class="fu">Point2d</span>(<span class="dv">1</span>, <span class="dv">2</span>))</code></pre>
<h2 id="miscellaneous">Miscellaneous</h2>
<p>There are a few other things to keep in mind when implementing <code>equals</code>. I won’t dwell on them though, they’re exactly the same as in Java:</p>
<ul>
<li>avoid using mutable fields in <code>equals</code> and <code>hashCode</code>.</li>
<li>if <code>a == b</code>, then <code>a.hashCode == b.hashCode</code> (but the opposite doesn’t need to, and often cannot, be true).</li>
</ul>

        </div>
    </body>
</html>
