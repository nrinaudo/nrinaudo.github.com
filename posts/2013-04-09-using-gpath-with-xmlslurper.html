<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Using GPath with XmlSlurper</title>
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link rel="stylesheet" type="text/css" href="../css/fontjolly.css" />
        <link rel="icon" type="image/png" href="../images/favicon.png">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Home</a>
                <a href="../archive.html">Archives</a>
            </div>
            <div id="navigation">
                <a title="GitHub" href="https://github.com/nrinaudo"><span class="ico-social-github"></span></a>
                <a title="Twitter" href="https://twitter.com/NicolasRinaudo"><span class="ico-social-twitter"></span></a>
                <a title="Stack Overflow" href="http://stackoverflow.com/users/1370349/nicolas-rinaudo"><span class="ico-line-chart"></span></a>
            </div>
        </div>

        <div id="content">
            <h1>Using GPath with XmlSlurper</h1>
<div class="info"><span class="date">2013-04-09</span><span class="tags"><a href="../tags/groovy.html" class="tag">groovy</a></span></div>
<p>Writing quick, discardable tools to parse some sort of XML, extract information from it and put it somewhere else is something I have to do with some regularity.</p>
<p>The best tool I currently have for this is Groovy - it has access to the wealth of existing Java libraries, but with a much more flexible syntax that does away with most of its parent’s boilerplate.</p>
<p>Also, mostly, <code>XmlSlurper</code> and GPath. These make loading and extracting information from XML so smooth and easy that one would almost forget what a nightmare Java’s internal XML APIs can be.</p>
<p>That’s the theory, at least, but it doesn’t appear to work for me. Whenever I have to use GPath, I find myself stimmied by the same problems. Time and time again, I’ll forget the difference between <code>grep</code> and <code>find</code>, or fail to remember that detph- or breadth-first searches change the rules slightly.</p>
<p>Not anymore. Since my brain obviously has some sort of block as far as GPath syntax is concerned, this post will do in its stead.</p>
<!--more-->

<p>In the rest of this post, the <code>xml</code> object is assumed to have been obtained through one of <code>XmlSlurper</code>’s <code>parse</code> methods.</p>
<h2 id="finding-an-element-by-name">Finding an element by name</h2>
<p>The first things I <em>always</em> stumble on is attempting to find all the elements of one type contained in an XML document - say, for example, all <code>li</code> elements in an HTML file.</p>
<p>What I want to write is:</p>
<pre class="groovy"><code>xml.'**'.li.each {
    // processing code
}</code></pre>
<p>And, for some reason, I <em>always</em> distinctly remember having gotten it to work in the past.</p>
<p>Well, I haven’t. This syntax isn’t supported nor, as far as I can tell, has it ever been.</p>
<p><code>**</code> is an alias for <code>depthFirst()</code>, which returns an iterator - a Groovy enhanced one, certainly, but still not one that supports nested GPath expressions.</p>
<p>Here’s what you want to do:</p>
<pre class="groovy"><code>xml.'**'.findAll {it.name() == 'li'}.each {
    // processing code
}</code></pre>
<p>Pay attention to the way the element’s name is retrieved: it’s <code>it.name()</code>, not <code>it.name</code>. A method, not a property.</p>
<p>While this might seem like an odd design choice, there’s a very good reason for it: properties describe children of the current node, so <code>it.name</code> would referrer to a <code>name</code> child element rather than the element’s name.</p>
<h2 id="grep-vs-find-vs-findall">grep VS find VS findAll</h2>
<p>These three methods have very similar contracts and purposes, but differ in ways that always do my head in.</p>
<p>I’ll use the following input to illustrate these differences:</p>
<pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;html&gt;</span>
    <span class="kw">&lt;body&gt;</span>
        <span class="kw">&lt;ul&gt;</span>
            <span class="kw">&lt;li</span><span class="ot"> class=</span><span class="st">&quot;odd&quot;</span><span class="kw">&gt;&lt;span&gt;</span>Element 1<span class="kw">&lt;/span&gt;&lt;/li&gt;</span>
            <span class="kw">&lt;li</span><span class="ot"> class=</span><span class="st">&quot;even&quot;</span><span class="kw">&gt;&lt;span&gt;</span>Element 2<span class="kw">&lt;/span&gt;&lt;/li&gt;</span>
            <span class="kw">&lt;li</span><span class="ot"> class=</span><span class="st">&quot;odd&quot;</span><span class="kw">&gt;&lt;span&gt;</span>Element 3<span class="kw">&lt;/span&gt;&lt;/li&gt;</span>
            <span class="kw">&lt;li</span><span class="ot"> class=</span><span class="st">&quot;even&quot;</span><span class="kw">&gt;&lt;span&gt;</span>Element 4<span class="kw">&lt;/span&gt;&lt;/li&gt;</span>
            <span class="kw">&lt;li</span><span class="ot"> class=</span><span class="st">&quot;odd&quot;</span><span class="kw">&gt;&lt;span&gt;</span>Element 5<span class="kw">&lt;/span&gt;&lt;/li&gt;</span>
        <span class="kw">&lt;/ul&gt;</span>
    <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre>
<h3 id="find">find</h3>
<p><code>find</code> is the simplest of the three: it returns the first node for which its lambda argument returns <code>true</code>.</p>
<p>For example:</p>
<pre class="groovy"><code>// Finds the first li element with a class attribute of odd.
// Outputs 'Element 1'.
xml.body.ul.li.find {it.@class == 'odd'}.each {
    println it.text()
}</code></pre>
<p>The returned value is an instance of <code>NodeChild</code>, which is convenient: you’ve just essentially obtained the root of a sub-tree of your original XML document, and can treat it exactly as you did the <code>xml</code> object - by, for example, chaining additional GPath filters.</p>
<p>The following example is perfectly valid (and convenient):</p>
<pre class="groovy"><code>// Outputs 'Element 1'
xml.body.ul.li.find {it.@class == 'odd'}.span.each {
    println it.text()
}</code></pre>
<p>Bear in mind that, once you’ve called <code>find</code>, you’ve restricted yourself to the <em>first</em> element that matched your lambda <em>only</em>. I’m sure normal people don’t have a problem with that, but it seems to slip my mind rather often.</p>
<h3 id="findall">findAll</h3>
<p><code>findAll</code> is also fairly simple: it returns all nodes for which its function argument returns <code>true</code>.</p>
<p>For example:</p>
<pre class="groovy"><code>// Finds all li elements with a class attribute of odd.
// Outputs 'Element 1\nElement 3\nElement 5\n'
xml.body.ul.li.findAll {it.@class == 'odd'}.each {
    println it.text()
}</code></pre>
<p>The returned value is an instance of <code>FilteredNodeChildren</code>, a subclass of <code>GPathResult</code>, which <em>should</em> be nice but looks… unfinished.</p>
<p>It basically supports the same nested GPath filters as <code>find</code>, with one very notable exception.</p>
<pre class="groovy"><code>// Does exactly what you'd expect: prints 'odd\nodd\nodd\n'
xml.body.ul.li.findAll {it.@class == 'odd'}.@class.each {println it.text()}

// Doesn't do what you'd expect at all: no span element is found.
xml.body.ul.li.findAll {it.@class == 'odd'}.span.each {println it.text()}</code></pre>
<p>This has had me scratching my head for a while, but I can’t find a reason why the <code>span</code> selector doesn’t work. I’m not confident enough in my Groovy skills to call this a bug in the standard APIs, but looking at the corresponding code, it looks like it should work but doesn’t.</p>
<p>The only solution I could find was to use the <a href="http://groovy.codehaus.org/Operators#Operators-SpreadOperator">spread operator</a> as follows:</p>
<pre class="groovy"><code>// Outputs 'Element 1\nElement 3\nElement 5\n'
xml.body.ul.li.findAll {it.@class == 'odd'}*.span.each {println it.text()}</code></pre>
<p>While this works, I find it unsatisfactory: it looks out of place in what is an otherwise fairly clean GPath expression. I’ll keep looking and update this post should I find a reason, but for the moment, future self, bear in mind that <code>findAll</code> feels a bit broken. You’d want its result to be manipulable in exactly the same way <code>find</code>’s result is, but this is just not the case.</p>
<p><em>Edit: this is apparently a reported <a href="https://jira.codehaus.org/browse/GROOVY-6122">bug</a> and will hopefully be fixed eventually</em></p>
<h3 id="grep">grep</h3>
<p><code>grep</code> is where I usually get stuck. At a glance, its signature and purpose are the same as <code>findAll</code>’s.</p>
<p>For example:</p>
<pre class="groovy"><code>// Finds all li elements with a class attribute of odd.
// Outputs 'Element 1\nElement 3\nElement 5\n'
xml.body.ul.li.grep {it.@class == 'odd'}.each {
    println it.text()
}</code></pre>
<p>There are, however, two differences between <code>findAll</code> and <code>grep</code>’s signatures.</p>
<p>The first one is that <code>grep</code>’s argument isn’t a lambda but an object whose <code>isCase(Object)</code> method will be evaluated. You can pass in a lambda, in which case the behaviour will be identical to that of <code>findAll</code>, but you could also pass any object with a useful <code>isCase</code> method.</p>
<p>The second difference is in the return type: <code>ArrayList&lt;NodeChild&gt;</code>. Groovy collections have a fun if sometimes misleading feature used to simplify calls to <code>collect</code>. The following calls are strictly equivalent:</p>
<pre class="groovy"><code>def set = ['foo', 'bar']

// Returns ['foo'.bytes, 'bar'.bytes]
set.collect {it.bytes}

// Does the same thing in a slightly more idiomatic way.
set.bytes</code></pre>
<p>This means that the following code is perfectly correct, and will behave exactly as one would expect:</p>
<pre class="groovy"><code>xml.body.ul.li.grep {it.@class == 'odd'}.span.each {
    println it.text()
}</code></pre>
<p>Which is brilliant, until you write the following:</p>
<pre class="groovy"><code>xml.body.ul.li.grep {it.@class == 'odd'}.'**'.findAll {it.name() == 'span'}.each {
    println it.text()
}</code></pre>
<p>This, as it turns out, throws an exception that is frustrating to understand. This is what happens, laid out step by step:</p>
<pre class="groovy"><code>// 'nodes' is an ArrayList&lt;NodeChild&gt;
def nodes = xml.body.ul.li.grep {it.@class == 'odd'}

// This is strictly equivalent to nodes.collect {it.'**'}.
// 'search' isn't an Iterator&lt;NodeChild&gt; but an ArrayList&lt;Iterator&lt;NodeChild&gt;&gt;
def search = nodes.'**'

// You'd expect 'it' to be a NodeChild, but you actually get an Iterator&lt;NodeChild&gt;.
// Iterators don't support the name() method, which is where the exception is raised.
search.findAll {it.name() == 'span'}.each {
    println it.text()
}</code></pre>

        </div>
    </body>
</html>
