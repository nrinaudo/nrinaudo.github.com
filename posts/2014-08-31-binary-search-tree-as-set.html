<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Binary Search Trees as Sets</title>
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link rel="stylesheet" type="text/css" href="../css/fontjolly.css" />
        <link rel="icon" type="image/png" href="../images/favicon.png">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Home</a>
                <a href="../archive.html">Archives</a>
            </div>
            <div id="navigation">
                <a title="GitHub" href="https://github.com/nrinaudo"><span class="ico-social-github"></span></a>
                <a title="Twitter" href="https://twitter.com/NicolasRinaudo"><span class="ico-social-twitter"></span></a>
                <a title="Stack Overflow" href="http://stackoverflow.com/users/1370349/nicolas-rinaudo"><span class="ico-line-chart"></span></a>
            </div>
        </div>

        <div id="content">
            <h1>Binary Search Trees as Sets</h1>
<div class="info"><span class="date">2014-08-31</span><span class="tags"><a href="../tags/scala.html" class="tag">scala</a> | <a href="../tags/haskell.html" class="tag">haskell</a></span></div>
<p>Binary search trees are the simplest implementation I know of a Set. This post shows how to write a <code>BinarySearchTree</code> implementation that works with the <a href="2014-08-21-purely-functional-sets.html">previous post</a>’s <code>Set</code> definition.</p>
<!--more-->

<h2 id="binary-search-tree">Binary Search Tree</h2>
<p>A binary search tree is a binary tree such that, for any given node <code>n</code>, all the values to its left are smaller than <code>n</code> and all the values to its right are larger than <code>n</code>.</p>
<div class="figure">
<img src="../images/graphs/binarysearchtrees/simple.svg" alt="Fig. 1: Simple binary search tree" /><p class="caption">Fig. 1: Simple binary search tree</p>
</div>
<p>You can see in figure 1 that the nodes to the left of <code>8</code> are <code>5</code>, <code>6</code> and <code>3</code>, which are all smaller than <code>8</code>. Similarly, the nodes to its right are <code>10</code>, <code>9</code> and <code>12</code>, which are all larger than <code>8</code>.</p>
<p>In the rest of this post, I’ll use the term <em>leaf</em> to mean a leaf in the <a href="http://mathworld.wolfram.com/ExtendedBinaryTree.html">extended representation</a> of the tree: a leaf does not contain a value, but represents the end of a branch.</p>
<h3 id="isempty-algorithm">“isEmpty” algorithm</h3>
<p>Checking whether a binary search tree is empty is trivial: if the root is a leaf, then it’s empty. Otherwise, it’s not.</p>
<h3 id="contains-algorithm">“contains” algorithm</h3>
<p>The algorithm for the <code>contains</code> operation is a straightforward recursion starting at the root of the tree:</p>
<ul>
<li>if the current node is a leaf, return <code>false</code>.</li>
<li>otherwise, if the desired value is smaller than the current node’s, look in the left sub-tree.</li>
<li>otherwise, if the desired value is larger than the current node’s, look in the right sub-tree.</li>
<li>otherwise, return <code>true</code>.</li>
</ul>
<p>Let’s take a few examples and run the algorithm.</p>
<div class="figure">
<img src="../images/graphs/binarysearchtrees/contains9.svg" alt="Fig. 2: Looking for an existing value" /><p class="caption">Fig. 2: Looking for an existing value</p>
</div>
<p>Trying to find <code>9</code> yields the following steps:</p>
<ul>
<li><code>9</code> is larger than <code>8</code>, explore the right sub-tree</li>
<li><code>9</code> is smaller than <code>10</code>, explore the left sub-tree</li>
<li>we’ve found <code>9</code>.</li>
</ul>
<div class="figure">
<img src="../images/graphs/binarysearchtrees/contains4.svg" alt="Fig. 3: Looking for a non-existing value" /><p class="caption">Fig. 3: Looking for a non-existing value</p>
</div>
<p>Trying to find <code>4</code> yields the following steps:</p>
<ul>
<li><code>4</code> is smaller than <code>8</code>, explore the left sub-tree</li>
<li><code>4</code> is smaller than <code>5</code>, explore the left sub-tree</li>
<li><code>4</code> is larger than <code>3</code>, explore the right sub-tree</li>
<li>we’re at a leaf, the set does not contain <code>4</code>.</li>
</ul>
<h3 id="insert-algorithm">“insert” algorithm</h3>
<p>Modification of purely functional data structures can be tricky: it requires cloning the source structure and updating it just enough to reflect the desired modifications, while at the same time re-using as much of it as possible.</p>
<p>Note that re-using parts of purely functional data structures is not unsafe: since they’re immutable by definition, it’s not possible for modifications in one to be reflected in another.</p>
<p>Insertion in binary search trees is fairly straightforward: recursively look for the node in which the desired value should be inserted, cloning all explored nodes along the way and re-using the sub-tree that is <em>not</em> impacted by the modification.</p>
<p>The only two special cases are leafs (in which case we found where to insert the value) or nodes that already contain the value (in which case we do not in fact need to insert it and can abort).</p>
<p>This is more easily explained with a graph (blue nodes are created during insertion, black ones are the original tree):</p>
<div class="figure">
<img src="../images/graphs/binarysearchtrees/insert4.svg" alt="Fig. 4: Inserting a value" /><p class="caption">Fig. 4: Inserting a value</p>
</div>
<p>Figure 4 shows the result of inserting <code>4</code> in our example tree.</p>
<p>In our first recusive step, we find that <code>4</code> is smaller than <code>8</code>: we need to clone the current node and insert <code>4</code> in its left sub-tree.</p>
<p><code>4</code> is also smaller than <code>5</code>: we need to clone it and insert <code>4</code> in its left sub-tree.</p>
<p><code>4</code> is larger than <code>3</code>: we need to clone it and insert <code>4</code> in its right sub-tree.</p>
<p>Finally, we’ve found a leaf and return a new node whose value is <code>4</code>.</p>
<p>The result is a new tree that re-uses as much of the source one as possible: <code>10</code> and all its descendants, as well as <code>6</code> and all its descendants, are shared by the original and output trees.</p>
<h2 id="scala-implementation">Scala implementation</h2>
<h3 id="binarysearchtree">BinarySearchTree</h3>
<p>We’ll implement binary search trees as an algebraic data type. In Scala, this means starting with a sealed trait to define the common operations:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> BinarySearchTree[<span class="dt">A</span>] {
  <span class="kw">def</span> isEmpty       : <span class="dt">Boolean</span>
  <span class="kw">def</span> <span class="fu">add</span>(a: <span class="dt">A</span>)     : <span class="dt">BinarySearchTree[A]</span>
  <span class="kw">def</span> <span class="fu">contains</span>(a: <span class="dt">A</span>): <span class="dt">Boolean</span>
<span class="dt">}</span></code></pre>
<p>Note that both our <code>add</code> and <code>contains</code> algorithms require <code>A</code> to be ordered. Since we can only work with ordered data, we’d like to state that constraint explicitely in the trait’s type signature:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> BinarySearchTree[<span class="dt">A: Ordering</span>] {...}</code></pre>
<p>This is, unfortunately, impossible: context bounds are compiled as implicit parameters, which means our previous code would compile to a trait with a constructor expecting one implicit parameter:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> BinarySearchTree[<span class="dt">A</span>](<span class="kw">implicit</span> ord: <span class="dt">Ordering[A]</span>) {...}</code></pre>
<p>Since Scala trait constructors cannot have parameters, the above code cannot compile.</p>
<p>We could also mark <code>add</code> and <code>contains</code> with an <code>Ordering</code> context bound, but that would come back and haunt us later when we try to write a <code>SetLike</code> implementation. Take the signature of <code>SetLike</code>’s <code>insert</code> method, for example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> insert[<span class="dt">A</span>](a: <span class="dt">A,</span> as: <span class="dt">Impl[A]</span>): <span class="dt">Impl[A]</span></code></pre>
<p>It does not expect an <code>Ordering[A]</code> as a parameter, either implicitly or explicitly - we would not have an ordering to pass to <code>BinarySearchTree</code>’s <code>add</code> method and no way to get one.</p>
<h3 id="leaf">Leaf</h3>
<p>Having written our algebraic data type’s contract, we must implement its alternatives. Let’s start with the simple one, <code>Leaf</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> Leaf[<span class="dt">A: Ordering</span>]() <span class="kw">extends</span> BinarySearchTree[<span class="dt">A</span>] {
  <span class="co">// A leaf is always empty.</span>
  <span class="kw">override</span> <span class="kw">def</span> isEmpty = <span class="kw">true</span>

  <span class="co">// A leaf never contains anything.</span>
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">contains</span>(a: <span class="dt">A</span>) = <span class="kw">false</span>

  <span class="co">// Inserting a value in a leaf is always done by creating a new tree.</span>
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">add</span>(a: <span class="dt">A</span>) = <span class="fu">Node</span>(a, <span class="kw">this</span>, <span class="kw">this</span>)
}</code></pre>
<p>There are a few things to note in this implementation.</p>
<p>The first one is how neatly this implements the bottom cases of the recursive algorithms we defined for <code>insert</code> and <code>contains</code> - a leaf never contains anything, and inserting a new value in a leaf is always done by creating a new node.</p>
<p>Another interesting point is that <code>Leaf</code> has a type constraint on <code>A</code>: there must be an implicit instance of <code>Ordering[A]</code> in scope. The reason for this might not be immediately obvious, but it’s required by <code>add</code>’s implementation: we’ll see later that <code>Node</code>’s constructor require an implicit <code>Ordering[A]</code>.</p>
<p>Finally, <code>Leaf</code> is a bit of a strange beast: it’s a case class with no field, but not a case object. This is sub-optimal, as it means that we’ll have a new instance of <code>Leaf</code> for each leaf in our trees rather than a single instance shared across all trees.</p>
<p>The reason for this implementation is that I’m more interested in the data structures themselves than Scala plumbing at this point, and in order for <code>Leaf</code> to be a case object, I’d need <code>BinarySearchTree</code> to be covariant and <code>Leaf</code> to be a <code>BinarySearchTree[Nothing]</code>. Adding covariance to the juggling I’m already doing with the type system will only add confusion - I’m sure it’s possible, and I’d absolutely do it if I thought my collection implementations had the slightest chance of being used by anyone, but that’s really not the purpose of this post.</p>
<h3 id="node">Node</h3>
<p>We can finally implement the meat of our <code>BinarySearchTree</code>: <code>Node</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> Node[<span class="dt">A</span>](value: <span class="dt">A,</span> left: <span class="dt">BinarySearchTree[A],</span> right: <span class="dt">BinarySearchTree[A]</span>)(<span class="kw">implicit</span> ord: <span class="dt">Ordering[A]</span>)
  <span class="kw">extends</span> BinarySearchTree[<span class="dt">A</span>] {
  <span class="co">// A node is never empty.</span>
  <span class="kw">override</span> <span class="kw">def</span> isEmpty = <span class="kw">false</span>

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">add</span>(a: <span class="dt">A</span>) =
    <span class="kw">if</span>(ord.<span class="fu">lt</span>(a, value))      <span class="fu">copy</span>(left  = left + a)
    <span class="kw">else</span> <span class="kw">if</span>(ord.<span class="fu">gt</span>(a, value)) <span class="fu">copy</span>(right = right + a)
    <span class="kw">else</span>                      <span class="kw">this</span>

  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">contains</span>(a: <span class="dt">A</span>) =
    <span class="kw">if</span>(ord.<span class="fu">lt</span>(a, value))      left.<span class="fu">contains</span>(a)
    <span class="kw">else</span> <span class="kw">if</span>(ord.<span class="fu">gt</span>(a, value)) right.<span class="fu">contains</span>(a)
    <span class="kw">else</span>                      <span class="kw">true</span>
}</code></pre>
<p>The first thing to point out in this implementation is that it can be optimised: both <code>add</code> and <code>contains</code> are recursive, but neither of them is tail-recursive. That’s fine for demonstration purposes, and makes the code quite a bit more legible, but it’d probably be a desirable optimsation if <code>Node</code> were to be used in a production a environment.</p>
<p>Note how clearly case classes allow us to express our cloning algorithm: the <code>copy</code> method makes it obvious that the only difference between the current node and the one that is returned is the sub-tree in which we drill down.</p>
<p>On the other hand, I’m a bit annoyed that I couldn’t find a sane way to use operators such as <code>&lt;</code> and <code>&gt;</code> rather than the more verbose <code>ord.lt</code> and <code>ord.gt</code>. It feels like an obvious way to make the code clearer, but I just didn’t manage to get it to work.</p>
<h3 id="implicit-conversion-to-set">Implicit conversion to <code>Set</code></h3>
<p>In order for our <code>BinarySearchTree</code> to be usable as a <code>Set</code>, we still need to write the corresponding, trivial <code>SetLike</code> implementation:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">object</span> AsSet <span class="kw">extends</span> SetLike[<span class="dt">BinarySearchTree</span>] {
  <span class="kw">override</span> <span class="kw">def</span> isEmpty[<span class="dt">A</span>](as: <span class="dt">BinarySearchTree[A]</span>)        = as.<span class="fu">isEmpty</span>
  <span class="kw">override</span> <span class="kw">def</span> insert[<span class="dt">A</span>](a: <span class="dt">A,</span> as: <span class="dt">BinarySearchTree[A]</span>)   = as + a
  <span class="kw">override</span> <span class="kw">def</span> contains[<span class="dt">A</span>](a: <span class="dt">A,</span> as: <span class="dt">BinarySearchTree[A]</span>) = as.<span class="fu">contains</span>(a)
}</code></pre>
<h2 id="haskell-implementation">Haskell implementation</h2>
<h3 id="binarysearchtree-1">BinarySearchTree</h3>
<p>As with our Scala implementation, we’ll define binary search trees as an algebraic data type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BinarySearchTree</span> a <span class="fu">=</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Node</span> a (<span class="dt">BinarySearchTree</span> a) (<span class="dt">BinarySearchTree</span> a)
                        <span class="fu">|</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Leaf</span></code></pre>
<p>Note that we’ll need the <code>ExistentialQuantification</code> to be able to declare type constraints at the data constructor level. This allows us to ensure that only values that can be ordered are added in our binary search trees, the same way we did for the Scala implementation.</p>
<h3 id="set-implementation">Set implementation</h3>
<p>Now that we have our data structure, we need to turn it into a valid <code>Set</code> implementation:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Set</span> <span class="dt">BinarySearchTree</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">SetEntry</span> <span class="dt">BinarySearchTree</span> a <span class="fu">=</span> <span class="dt">Ord</span> a

  empty <span class="fu">=</span> <span class="dt">Leaf</span>

  isEmpty <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dt">True</span>
  isEmpty _    <span class="fu">=</span> <span class="dt">False</span>

  contains <span class="dt">Leaf</span> _ <span class="fu">=</span> <span class="dt">False</span>
  contains (<span class="dt">Node</span> v l r) a
    <span class="fu">|</span> a <span class="fu">&lt;</span> v     <span class="fu">=</span> contains l a
    <span class="fu">|</span> a <span class="fu">&gt;</span> v     <span class="fu">=</span> contains r a
    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">True</span>

  insert <span class="dt">Leaf</span> a <span class="fu">=</span> <span class="dt">Node</span> a <span class="dt">Leaf</span> <span class="dt">Leaf</span>
  insert s<span class="fu">@</span>(<span class="dt">Node</span> v l r) a
    <span class="fu">|</span> a <span class="fu">&lt;</span> v <span class="fu">=</span> <span class="dt">Node</span> v (insert l a) r
    <span class="fu">|</span> a <span class="fu">&gt;</span> v <span class="fu">=</span> <span class="dt">Node</span> v l (insert r a)
    <span class="fu">|</span> otherwise <span class="fu">=</span> s</code></pre>
<p>In order for this to compile, we’ll need a mess of compiler flags: <code>TypeFamilies</code>, <code>MultiParamTypeClasses</code> and <code>FlexibleInstances</code>.</p>
<p>There really isn’t anything special to say about this code, aside from noting how clear it is. Provided you can read Haskell, this could almost be the specifications for our binary search tree algorithms.</p>

        </div>
    </body>
</html>
