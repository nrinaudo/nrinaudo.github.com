<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Purely functional heaps</title>
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link rel="stylesheet" type="text/css" href="../css/fontjolly.css" />
        <link rel="icon" type="image/png" href="../images/favicon.png">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Home</a>
                <a href="../archive.html">Archives</a>
            </div>
            <div id="navigation">
                <a title="GitHub" href="https://github.com/nrinaudo"><span class="ico-social-github"></span></a>
                <a title="Twitter" href="https://twitter.com/NicolasRinaudo"><span class="ico-social-twitter"></span></a>
                <a title="Stack Overflow" href="http://stackoverflow.com/users/1370349/nicolas-rinaudo"><span class="ico-line-chart"></span></a>
            </div>
        </div>

        <div id="content">
            <h1>Purely functional heaps</h1>
<div class="info"><span class="date">2014-08-31</span><span class="tags"><a href="../tags/purely%20functional%20data%20structures.html" class="tag">purely functional data structures</a> | <a href="../tags/scala.html" class="tag">scala</a> | <a href="../tags/haskell.html" class="tag">haskell</a></span></div>
<p>Heaps are another simple data structure that can easily be implemented as type classes. Just as with <a href="../posts/2014-08-21-purely-functional-sets.html">sets</a>, this first post will explain what a heap is and how to define it, while later ones will show actual implementations.</p>
<!--more-->

<h2 id="abstract-definition">Abstract definition</h2>
<p>There seems to be some debate as to what exactly constitutes a heap.</p>
<p>According to some sources (such as <a href="http://en.wikipedia.org/wiki/Heap_(data_structure)">Wikipedia</a>), a heap is tree-like structure that satisfies the <em>heap property</em>, which states that the value of each node is not greater than the value of its descendants.</p>
<p>Others, such as Chris Okasaki, define a heap as synonymous to a priority queue, an abstract data structure that provides primitives for acccess to and removal of its element with the smallest value (or lowest priority).</p>
<p>Within the context of this post, we’ll use a somewhat custom-made definition that, while possibly not entirely correct, seems like an acceptable compromise.</p>
<p>A heap, then, is an abstract data type that supports the following operations:</p>
<ul>
<li><code>isEmpty</code>: checks whether the heap is empty.</li>
<li><code>insert</code>: inserts an element in the heap.</li>
<li><code>findMin</code>: finds the minimum value in the heap.</li>
<li><code>deleteMin</code>: returns a new heap that does not contain the previous one’s minimum element.</li>
</ul>
<p>Within this context, the Wikipedia definition is that of <em>heap-ordered trees</em>, a family of concrete implementations of the heap abstract data type (such as splay heap, leftist heap, binomial heap…).</p>
<p>Note that, technically, we’ve just defined a min-heap, not a generic one. Since we’ll be working with customisable orderings however, this isn’t much an issue: turning a min-heap into a max-heap is as simple as inverting the ordering.</p>
<h2 id="scala-definition">Scala definition</h2>
<p>As usual, we start with the behaviour of heap-like data structures:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> scala.language.higherKinds

<span class="kw">trait</span> HeapLike[<span class="dt">Impl[_]</span>] {
  <span class="kw">def</span> isEmpty[<span class="dt">A</span>](a: <span class="dt">Impl[A]</span>)      : <span class="dt">Boolean</span>
  <span class="kw">def</span> insert[<span class="dt">A</span>](a: <span class="dt">A,</span> as: <span class="dt">Impl[A]</span>): <span class="dt">Impl[A]</span>
  <span class="kw">def</span> findMin[<span class="dt">A</span>](a: <span class="dt">Impl[A]</span>)      : <span class="dt">Option[A]</span>
  <span class="kw">def</span> deleteMin[<span class="dt">A</span>](a: <span class="dt">Impl[A]</span>)    : <span class="dt">Impl[A]</span>
<span class="dt">}</span></code></pre>
<p>Nothing special there, it’s essentialy the same thing we did for <a href="2014-08-21-purely-functional-sets.html#scala-definition">sets</a>.</p>
<p>We could technically require an <code>Ordering</code> instance of <code>A</code> for all these methods, but it’s not strictly required nor really useful: <code>HeapLike</code> does not contain any code that actually needs its elements to be ordered.</p>
<p>That done, we can define the <code>Heap</code> trait for data structures that are actual heaps:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Heap[<span class="dt">A</span>] {
  <span class="kw">def</span> isEmpty     : <span class="dt">Boolean</span>
  <span class="kw">def</span> <span class="fu">insert</span>(a: <span class="dt">A</span>): <span class="dt">Heap[A]</span>
  <span class="kw">def</span> findMin     : <span class="dt">Option[A]</span>
  <span class="kw">def</span> <span class="fu">deleteMin</span>() : <span class="dt">Heap[A]</span>
<span class="dt">}</span></code></pre>
<p>And finally, the implicit conversion from <code>HeapLike</code> to <code>Heap</code>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">class</span> Wrapped[<span class="dt">A, Impl[_]</span>](<span class="kw">val</span> heap: <span class="dt">Impl[A]</span>)(<span class="kw">implicit</span> heapLike: <span class="dt">HeapLike[Impl]</span>) <span class="kw">extends</span> Heap[<span class="dt">A</span>] {
  <span class="kw">override</span> <span class="kw">def</span> isEmpty      = heapLike.<span class="fu">isEmpty</span>(heap)
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">insert</span>(a: <span class="dt">A</span>) = <span class="kw">new</span> <span class="fu">Wrapped</span>(heapLike.<span class="fu">insert</span>(a, heap))
  <span class="kw">override</span> <span class="kw">def</span> findMin      = heapLike.<span class="fu">findMin</span>(heap)
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">deleteMin</span>()  = <span class="kw">new</span> <span class="fu">Wrapped</span>(heapLike.<span class="fu">deleteMin</span>(heap))
}</code></pre>
<h2 id="haskell-definition">Haskell definition</h2>
<p>As often seems to be the case, the Haskell definition is quite a bit shorter:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">GHC.Prim</span>

<span class="kw">class</span> <span class="dt">Heap</span> h <span class="kw">where</span>
  <span class="co">-- Constraint that elements of h must respect.</span>
  <span class="kw">type</span> <span class="dt">HeapEntry</span> h<span class="ot"> a ::</span> <span class="dt">Constraint</span>
  <span class="kw">type</span> <span class="dt">HeapEntry</span> h a <span class="fu">=</span> ()

<span class="ot">  empty     ::</span> <span class="dt">HeapEntry</span> h a <span class="ot">=&gt;</span> h a
<span class="ot">  isEmpty   ::</span> h a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">  findMin   ::</span> h a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
<span class="ot">  deleteMin ::</span> h a <span class="ot">-&gt;</span> h a
<span class="ot">  insert    ::</span> <span class="dt">HeapEntry</span> h a <span class="ot">=&gt;</span> h a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> h a</code></pre>
<p>The only tricky part is our dynamic constraint on the values contained by the heap, which allows implementations to set their own custom constraints - <code>Ord</code>, say, or <code>Numeric</code>.</p>
<p>Note where this constraint is actually applied:</p>
<ul>
<li><code>insert</code>, since it receives an instance of <code>a</code>.</li>
<li><code>empty</code>, to prevent instances of <code>Heap</code> from being created for types not supported by the underlying implementation.</li>
</ul>
<p>Finally, we’ve added a the <code>empty</code> method to conform with Purely Functional Data Structure’s implementation.</p>

        </div>
    </body>
</html>
