<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Purely functional sets</title>
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link rel="stylesheet" type="text/css" href="../css/fontjolly.css" />
        <link rel="icon" type="image/png" href="../images/favicon.png">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Home</a>
                <a href="../archive.html">Archives</a>
            </div>
            <div id="navigation">
                <a title="GitHub" href="https://github.com/nrinaudo"><span class="ico-social-github"></span></a>
                <a title="Twitter" href="https://twitter.com/NicolasRinaudo"><span class="ico-social-twitter"></span></a>
                <a title="Stack Overflow" href="http://stackoverflow.com/users/1370349/nicolas-rinaudo"><span class="ico-line-chart"></span></a>
            </div>
        </div>

        <div id="content">
            <h1>Purely functional sets</h1>
<div class="info"><span class="date">2014-08-21</span><span class="tags"><a href="../tags/purely%20functional%20data%20structures.html" class="tag">purely functional data structures</a> | <a href="../tags/scala.html" class="tag">scala</a> | <a href="../tags/haskell.html" class="tag">haskell</a></span></div>
<p>I <a href="2014-08-11-collections-as-typeclasses.html">previously talked</a> about implementing collections as type classes, using <code>Stack</code> as an example. This post shows the basic contract for a purely functional <code>Set</code>, with actual implementation examples to follow.</p>
<!--more-->

<h2 id="abstract-definition">Abstract definition</h2>
<p>A set is a fairly simple abstract data structure: all it does is store unique values. The way these values are stored is unspecified - in particular, there is no constraint on their order, or even on whether that order is stable. In their rawest forms, sets do not even need to offer a way to iterate over their values.</p>
<p>Their interest lies in the unicity constraint: a value can never be present more than once in a given set. Or, to put it in more mathy terms: the value insertion operation is idempotent. That is, there is no difference between calling it once or many times for the same value.</p>
<p>The core operations that a set must support are:</p>
<ul>
<li><code>isEmpty</code>: checks whether the set is empty.</li>
<li><code>insert</code>: inserts a value in the set.</li>
<li><code>contains</code>: checks whether a value is contained in the set.</li>
</ul>
<p>Note that since we’re talking about a purely functional set, it must be immutable - that is, calling <code>insert</code> on a set <code>S</code> must not modify it, but return a copy of <code>S</code> that also contains the new value.</p>
<h2 id="scala-definition">Scala definition</h2>
<p>In a previous post, I’ve shown how to define <a href="2014-08-11-collections-as-typeclasses.html">collections as type classes</a>. We’ll do the exact same thing here.</p>
<p>First, we need to define the behaviour of set-like data structures:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> scala.language.higherKinds

<span class="kw">trait</span> SetLike[<span class="dt">Impl[_]</span>] {
  <span class="kw">def</span> isEmpty[<span class="dt">A</span>](as: <span class="dt">Impl[A]</span>)       : <span class="dt">Boolean</span>
  <span class="kw">def</span> insert[<span class="dt">A</span>](a: <span class="dt">A,</span> as: <span class="dt">Impl[A]</span>)  : <span class="dt">Impl[A]</span>
  <span class="kw">def</span> contains[<span class="dt">A</span>](a: <span class="dt">A,</span> as: <span class="dt">Impl[A]</span>): <span class="dt">Boolean</span>
<span class="dt">}</span></code></pre>
<p>Note that since sets require their values to be unique, we must be able to compare them. We could have sneaked in an <code>Eq</code> type constraint here, but since it’s not strictly necessary, we can let implementations deal with this - especially since some, such as binary search trees, require something more than simple equality.</p>
<p>That done, we need to define the <code>Set</code> trait, for data structures that are actual sets:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Set[<span class="dt">A</span>] <span class="kw">extends</span> (A =&gt; Boolean) {
  <span class="kw">def</span> isEmpty       : <span class="dt">Boolean</span>
  <span class="kw">def</span> <span class="fu">insert</span>(a: <span class="dt">A</span>)  : <span class="dt">Set[A]</span>
  <span class="kw">def</span> <span class="fu">contains</span>(a: <span class="dt">A</span>): <span class="dt">Boolean</span>

  <span class="co">// Technically, we can consider a set to be a predicate: it's a function that takes one parameter and returns a</span>
  <span class="co">// boolean value.</span>
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">apply</span>(a: <span class="dt">A</span>): <span class="dt">Boolean</span> = <span class="fu">contains</span>(a)
}</code></pre>
<p>Finally, we must write an implicit conversion from set-like things to actual sets:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">class</span> Wrapped[<span class="dt">A, Impl[_]</span>](<span class="kw">val</span> set: <span class="dt">Impl[A]</span>)(<span class="kw">implicit</span> setLike: <span class="dt">SetLike[Impl]</span>) <span class="kw">extends</span> Set[<span class="dt">A</span>] {
  <span class="kw">override</span> <span class="kw">def</span> isEmpty        = setLike.<span class="fu">isEmpty</span>(set)
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">insert</span>(a: <span class="dt">A</span>)   = <span class="kw">new</span> <span class="fu">Wrapped</span>(setLike.<span class="fu">insert</span>(a, set))
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">contains</span>(a: <span class="dt">A</span>) = setLike.<span class="fu">contains</span>(a, set)
}</code></pre>
<p>Note that instead of using a context bound when declaring <code>Impl</code>, we’ve, err, explicitly declared the implicit parameter. Both are strictly equivalent, and since use <code>setLike</code> quite a bit in the implementation, it’s more convenient than having to use <code>implicitly[SetLike]</code> everywhere.</p>
<h2 id="haskell-definition">Haskell definition</h2>
<p>The definition of a Haskell set is quite a bit simpler than in Scala:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">GHC.Prim</span>

<span class="kw">class</span> <span class="dt">Set</span> s <span class="kw">where</span>
  <span class="co">-- Constraints on elements that s can contains.</span>
  <span class="co">-- None by default.</span>
  <span class="kw">type</span> <span class="dt">SetEntry</span> s<span class="ot"> a ::</span> <span class="dt">Constraint</span>
  <span class="kw">type</span> <span class="dt">SetEntry</span> s a <span class="fu">=</span> ()

<span class="ot">  empty    ::</span> <span class="dt">SetEntry</span> s a <span class="ot">=&gt;</span> s a
<span class="ot">  isEmpty  ::</span> s a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">  insert   ::</span> <span class="dt">SetEntry</span> s a <span class="ot">=&gt;</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s a
<span class="ot">  contains ::</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre>
<p>The tricky bit here is the <code>SetEntry</code> type constraint: it allows us to let instances of <code>Set</code> impose constraints on the data they contain. Binary search trees, for example, require ordered data, but this constraint is not applicable to all possible <code>Set</code> implementations.</p>
<p>Note that we’ve also added an <code>empty</code> method, used to create empty sets. This is probably not strictly necessary, but that’s how Chris Okasaki implements it - odds are good it’s the smart thing to do.</p>
<p>This code requires the <code>TypeFamilies</code> and <code>ConstraintKinds</code> flags to compile.</p>

        </div>
    </body>
</html>
