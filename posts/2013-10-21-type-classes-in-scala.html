<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Type classes in Scala</title>
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link rel="stylesheet" type="text/css" href="../css/fontjolly.css" />
        <link rel="icon" type="image/png" href="../images/favicon.png">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Home</a>
                <a href="../archive.html">Archives</a>
            </div>
            <div id="navigation">
                <a title="GitHub" href="https://github.com/nrinaudo"><span class="ico-social-github"></span></a>
                <a title="Twitter" href="https://twitter.com/NicolasRinaudo"><span class="ico-social-twitter"></span></a>
                <a title="Stack Overflow" href="http://stackoverflow.com/users/1370349/nicolas-rinaudo"><span class="ico-line-chart"></span></a>
            </div>
        </div>

        <div id="content">
            <h1>Type classes in Scala</h1>
<div class="info"><span class="date">2013-10-21</span><span class="tags"><a href="../tags/scala.html" class="tag">scala</a></span></div>
<p><em>Type classes</em> were an entirely new concept to me when I discovered them in Scala. Now that (I think) I understand them, however, they completely changed the way I think about code, inheritance and modularity.</p>
<!--more-->

<h2 id="purpose">Purpose</h2>
<p>Type classes are used to decorelate classes and their features, with the purpose of allowing developers to add functionalities to, or offer multiple version of the same functionality for, a given class <em>without modifying that class</em>.</p>
<p>Say, for example, that you’re using an external library that exposes a <code>Person</code> class, implemented as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Person</span>(first: <span class="dt">String,</span> last: <span class="dt">String</span>) {
  <span class="kw">override</span> <span class="kw">def</span> toString = <span class="st">&quot;%s %s&quot;</span> <span class="fu">format</span> (first, last)
}</code></pre>
<p>Your application holds a <code>List</code> of <code>Person</code> instances, and you’d like to sort them, say, alphabetically by family name. At this point, if the external library hasn’t already made <code>Person</code> sortable, you have very few options (short of re-implementing your own sort, which we want to avoid).</p>
<p>The first one is to create an adapter that implements <a href="http://www.scala-lang.org/api/current/index.html#scala.math.Ordered">Ordered</a>:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> <span class="fu">OrderedPerson</span>(<span class="kw">val</span> wrapped: <span class="dt">Person</span>) <span class="kw">extends</span> Ordered[<span class="dt">OrderedPerson</span>] {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">compare</span>(that: <span class="dt">OrderedPerson</span>): <span class="dt">Int</span> = wrapped.<span class="fu">last</span>.<span class="fu">compareTo</span>(that.<span class="fu">wrapped</span>.<span class="fu">last</span>)

  <span class="kw">override</span> <span class="kw">def</span> toString = wrapped.<span class="fu">toString</span>
}</code></pre>
<p>This works, but with a few flaws:</p>
<ul>
<li>you’re not working with instances of <code>Person</code> anymore, and need to transform your objects back and forth (or have <code>OrderedPerson</code> extend <code>Person</code> and proxy every single method)</li>
<li>implementing multiple sorting strategies (by first name, for example) is possible but requires a lot of legwork</li>
</ul>
<p>The other solution is to use the <a href="http://www.scala-lang.org/api/current/index.html#scala.math.Ordering">Ordering</a> type class as follows:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">object</span> LastNameOrdering <span class="kw">extends</span> Ordering[<span class="dt">Person</span>] {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">compare</span>(a: <span class="dt">Person,</span> b: <span class="dt">Person</span>): <span class="dt">Int</span> = a.<span class="fu">last</span>.<span class="fu">compareTo</span>(b.<span class="fu">last</span>)
}</code></pre>
<p>Since all Scala methods that sort objects accept an instance of <code>Ordering</code> (<code>List.sorted</code>, <code>Sorting.quickSort</code>…), <code>LastNameOrdering</code> has just retrofitted <code>Person</code> with the ability to be sorted without actually modifying its code. Implementing another sorting strategy is simply done by writing another implementation of <code>Ordering</code>. Additionally, since all methods that expect an instance of <code>Ordering</code> declare it as an implicit parameter, and we’ve made <code>LastNameOrdering</code> an implicit object, we don’t even need to explicitly pass it around - as long as it’s in scope, it will be used automatically by the compiler.</p>
<h2 id="writing-a-type-class">Writing a type class</h2>
<p>We now have a better understanding of what a type class is. Implementing one requires surprisingly little code and, thanks to Scala’s support of implicit parameters, can be made all but invisible to callers.</p>
<p>Let’s say that our application requires a facility for printing <code>Person</code> to <code>stdout</code>. A naive first implementation could be:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Printer {
  <span class="kw">def</span> <span class="fu">print</span>(p: <span class="dt">Person</span>) = <span class="fu">println</span>(p)
}</code></pre>
<p>This works, but is very limiting:</p>
<ul>
<li>the only supported format is that implemented by the <code>toString</code> method, and we’d need to write adapter classes for each format we want to add</li>
<li>it only works for <code>Person</code> - what if we have another <code>Company</code> class that we’d like to print to stdout as well? Do we need to write an entirely different printing facility for that?</li>
</ul>
<p>This is were type classes really shine. Instead of letting the object being printed decide how to format itself, we create a trait and delegate that responsability to it:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Used solely for the purpose of formatting instances of A.</span>
<span class="kw">trait</span> Formatter[<span class="dt">A</span>] {
  <span class="kw">def</span> <span class="fu">format</span>(a: <span class="dt">A</span>): <span class="dt">String</span>
<span class="dt">}</span>

<span class="dt">object</span> Printer {
  <span class="co">// Now accepts two parameters: an object to print, and an object that knows how to format it.</span>
  <span class="kw">def</span> print[<span class="dt">A</span>](a: <span class="dt">A,</span> f: <span class="dt">Formatter[A]</span>) = <span class="fu">println</span>(f<span class="fu">.format</span>(a))
}

<span class="co">// Person specific formatter.</span>
<span class="kw">object</span> PersonFormatter <span class="kw">extends</span> Formatter[<span class="dt">Person</span>] {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">format</span>(a: <span class="dt">Person</span>) = a.<span class="fu">last</span>
}

<span class="co">// We've now entirely de-coupled Person and its formatting mechanism.</span>
Printer.<span class="fu">print</span>(<span class="kw">new</span> <span class="fu">Person</span>(<span class="st">&quot;Robert&quot;</span>, <span class="st">&quot;Smith&quot;</span>), PersonFormatter)</code></pre>
<p>This is nice but a bit verbose. As usual, Scala has mechanism to reduce the verbosity: implicit parameters.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Printer {
  <span class="co">// The formatter is now an implicit parameter.</span>
  <span class="kw">def</span> print[<span class="dt">A</span>](a: <span class="dt">A</span>)(<span class="kw">implicit</span> f: <span class="dt">Formatter[A]</span>) = <span class="fu">println</span>(f<span class="fu">.format</span>(a))
}

<span class="co">// Declares an implicit Formatter[Person] in scope.</span>
<span class="kw">implicit</span> <span class="kw">object</span> PersonFormatter <span class="kw">extends</span> Formatter[<span class="dt">Person</span>] {
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">format</span>(a: <span class="dt">Person</span>) = a.<span class="fu">last</span>
}

<span class="co">// We can now omit the formatter entirely.</span>
Printer.<span class="fu">print</span>(<span class="kw">new</span> <span class="fu">Person</span>(<span class="st">&quot;Robert&quot;</span>, <span class="st">&quot;Smith&quot;</span>))</code></pre>
<p>From Scala 2.8 onwards, the same can be achieved through context bounds:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Printer {
  <span class="co">// [A: Formatter] should be read as &quot;class that has an associated implicit Formatter&quot;.</span>
  <span class="kw">def</span> print[<span class="dt">A: Formatter</span>](a: <span class="dt">A</span>) = <span class="fu">println</span>(implicitly[<span class="dt">Formatter[A]</span>]<span class="fu">.format</span>(a))
}</code></pre>
<p>Not only have we added a new formatting feature to <code>Person</code> without modifying its source code or extending it, but we’ve also done it for all possible classes. Nothing in our implementation ties us to <code>Person</code>: adding support for, say, dates, is simply done by writing a <code>Formatter</code> implementation for <code>Date</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> java.util.Date

<span class="co">// Formats dates as legal ISO 8601 strings.</span>
<span class="kw">implicit</span> <span class="kw">object</span> DateFormatter <span class="kw">extends</span> Formatter[<span class="dt">Date</span>] {
  <span class="kw">private</span> <span class="kw">val</span> formatter = <span class="kw">new</span> java.<span class="fu">text</span>.<span class="fu">SimpleDateFormat</span>(<span class="st">&quot;yyyy-MM-dd'T'HH:mm:ssz&quot;</span>)
  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">format</span>(date: <span class="dt">Date</span>) = formatter<span class="fu">.format</span>(date)
}

<span class="co">// Since DateFormatter is both implicit and in scope, there's no need to pass it explicitly.</span>
Printer.<span class="fu">print</span>(<span class="kw">new</span> <span class="fu">Date</span>())</code></pre>
<h2 id="type-safety">Type safety</h2>
<p>Another advantage of type classes is that, since they’re validated at compile time, they’re inherently safe. Subtype polymorphism is mostly safe, but must rely on trust in some cases. The following (contrived) example compiles, but fails at runtime:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">print</span>(a: <span class="dt">Any</span>) = <span class="fu">println</span>(a.<span class="fu">asInstanceOf</span>[<span class="dt">Person</span>].<span class="fu">first</span>)

<span class="fu">print</span>(<span class="kw">new</span> java.<span class="fu">util</span>.<span class="fu">Date</span>())</code></pre>
<p>Such a situation is not possible with type classes, where all types are know to and validated by the compiler.</p>

        </div>
    </body>
</html>
