---
layout: post
title: "Overriding abstract methods in Scala"
date: 2013-08-04 14:32
comments: true
categories: scala best-practice
---
Dear future self,

When implementing abstract methods in Scala, I always use the `override` keyword. I realised today that it appears not
to be compulsory - in fact, decompiling the generated bytecode through `javap` yields the same result whether or not
`override` was used.

Scala is very rarely that loose with its syntax, so I set out to understand what difference there was between the two
declarations, if any.

<!-- more -->

It seems the difference is mostly (only?) at compile time: `override` is a hint to the compiler that the method being
declared is thought to override a method of the same signature in one of the parent classes.

For example:
```scala
abstract class Callable {
  def call(): Unit
}

class ConcreteCallable extends Callable {
  // Lets the compiler know that we're expecting the call method to be declared in Callable
  override def call() {
    println("Called")
  }
}

class ConcreteCallable2 extends Callable {
  // Doesn't give any hint to the compiler.
  def call() {
    println("Called")
  }
}
```

This distinction matters when `Callable`'s contract change: if the `call` method were to disappear for whatever reason:
```scala
abstract class Callable {
}

// Fails to compile with the following message:
// error: method call overrides nothing
//  override def call() {
class ConcreteCallable extends Callable {
  override def call() {
    println("Called")
  }
}

// Compiles just fine.
class ConcreteCallable2 extends Callable {
  def call() {
    println("Called")
  }
}
```

I find the compilation error to be the desirable behaviour: it lets me know immediately that `ConcreteCallable` isn't
doing what it thinks it's doing anymore, and needs reviewing. The solution might sometimes be to remove the `override`
keyword, but more often than not, the compilation failure will forestall a hard-to-understand bug before it even has a
chance to manifest itself.
