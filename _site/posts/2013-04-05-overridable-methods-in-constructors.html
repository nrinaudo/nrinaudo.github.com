<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Overridable methods in constructors</title>
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link rel="stylesheet" type="text/css" href="../css/fontjolly.css" />
        <link rel="icon" type="image/png" href="../images/favicon.png">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Home</a>
                <a href="../archive.html">Archives</a>
            </div>
            <div id="navigation">
                <a title="GitHub" href="https://github.com/nrinaudo"><span class="ico-social-github"></span></a>
                <a title="Twitter" href="https://twitter.com/NicolasRinaudo"><span class="ico-social-twitter"></span></a>
                <a title="Stack Overflow" href="http://stackoverflow.com/users/1370349/nicolas-rinaudo"><span class="ico-line-chart"></span></a>
            </div>
        </div>

        <div id="content">
            <h1>Overridable methods in constructors</h1>
<div class="info"><span class="date">2013-04-05</span><span class="tags"><a href="../tags/java.html" class="tag">java</a></span></div>
<p>Calling an overridable method in a constructor is, or should be, widely known to be a bug in waiting. It’s also a pattern that is found much too often in production code. The purpose of this post is to explain <em>why</em> it’s such a bad idea.</p>
<!--more-->

<p>The root of the problem lies in the fact that a class’ parent’s constructor is always called before its own constructor is called, whether explicitly or implicitly.</p>
<p>That is, if class <code>A</code> extends class <code>B</code>, <code>A</code>’s constructor will <em>always</em> be called before <code>B</code>’s.</p>
<p>As a concrete example, the following class looks very simple and harmless:</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Parent {
    <span class="kw">public</span> <span class="fu">Parent</span>() {
        <span class="fu">demonstrate</span>();
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">demonstrate</span>() {
        <span class="co">// Left for sub-classes to override.</span>
    }
}</code></pre>
<p>The following subclass of <code>Parent</code>, however, behaves in a way that will take many by surprise, especially if they do not have access to <code>Parent</code>’s sources code:</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Child <span class="kw">extends</span> Parent {
    <span class="co">// Both private and final: most sane people will assume its value cannot change.</span>
    <span class="kw">private</span> <span class="dt">final</span> String field;

    <span class="co">// The first thing we do is set &quot;field&quot;'s value.</span>
    <span class="kw">public</span> <span class="fu">Child</span>(String value) {
        field = value;
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">demonstrate</span>() {
        field.<span class="fu">toLowerCase</span>(); <span class="co">// or any code that access field.</span>
    }

    <span class="fu">@Override</span>
    <span class="kw">public</span> String <span class="fu">toString</span>() {
        <span class="kw">return</span> field;
    }

    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String<span class="kw">... </span>args) {
        <span class="co">// You'd expect this to result in &quot;Hello, World!&quot; being printed to stdout.</span>
        <span class="kw">new</span> <span class="fu">Child</span>(<span class="st">&quot;Hello, World!&quot;</span>);
    }
}</code></pre>
<p>Compiling and executing <code>Child</code> <em>should</em> print <code>Hello, World!</code>, but results in a <code>NullPointerException</code> instead.</p>
<p>It’s fairly logical once it’s been pointed out:</p>
<ul>
<li><code>Parent</code>’s constructor is called before <code>Child</code>’s.</li>
<li>since <code>Parent</code>’s constructor calls <code>demonstrate()</code>, this will happen before <code>Child</code>’s constructor executes.</li>
<li><code>demonstrate()</code> access <code>field</code>, which cannot possibly have a value yet as it’s set in <code>Child</code>’s constructor.</li>
</ul>
<p>While obvious once pointed out, this is exactly the kind of bug that can prove time consuming to fix: a <code>private final</code> value that is always set to a non-<code>null</code> value cannot possibly be <code>null</code>, can it?</p>

        </div>
    </body>
</html>
