---
title: Type Classes from the Ground Up - Derivation
tags: scala
---

_WORK IN PROGRESS: this section still needs extensive work and might get scrapped / rewritten in its entirety. It's here
more to motivate me to complete it than to be read as a reliable explanation. Suggestions are welcome, though._


In this third post, we'll tackle the problem of deriving type class instances for case classes. Case classes are very
useful in scenarii where one might require CSV parsing - I find myself having to parse CSV data and store the resulting
values in a better structured database more often than I'd like, and representing each row as a dedicated case class
is very comfortable, especially if the library I'm using for output also supports some kind of type class based
serialisation mechanism.

This post might be a bit more complicated than the previous ones, as it requires using
[shapeless](https://github.com/milessabin/shapeless), a generic programming library. While the material we'll cover here
is relatively simple, it's perfectly fine to skip this post, as it's not a requirement to any of the remaining topics
we'll cover.

<!--more-->

See the [introduction](/2015/11/21/tcgu-part-0.html) for more context and a table of content for the whole series.


# What we've done so far

In the previous posts, we've come up with two type classes, `RowDecoder` and `CellDecoder`, used to parse CSV rows and
cells, respectively:

```scala
trait CellDecoder[T] {
  def decode(s: String): T
}

trait RowDecoder[T] {
  def decode(row: IndexedSeq[String]): T
}
```

These type classes are used by a `parseCsv` function that turns CSV data into an iterator of whatever type we want to
represent each row as:

```scala
import scala.io.Source

def parseCsv[A](input: Source)(implicit da: RowDecoder[A]): Iterator[A] =
  input.getLines.map(r => da.decode(r.split(",")))
```

We also defined a certain number of instances, such as `CellDecoder`s for `Int`, `String` and `Boolean`:

```scala
def cellDecoder[A](f: String => A): CellDecoder[A] = new CellDecoder[A] {
  override def decode(s: String) = f(s)
}

def rowDecoder[A](f: IndexedSeq[String] => A): RowDecoder[A] = new RowDecoder[A] {
  override def decode(ss: IndexedSeq[String]) = f(ss)
}

implicit val ints     = cellDecoder(_.toInt)
implicit val strings  = cellDecoder(identity)
implicit val booleans = cellDecoder(_.toBoolean)
```

While writing interesting instances of `RowDecoder`, however, we realised that we were kind of stuck with writing a
*lot* of boilerplate, and even then, we still required users of our library to do some manual work.

# Importing shapeless
Luckily, the [shapeless](https://github.com/milessabin/shapeless) library,
by [Miles Sabin](https://twitter.com/milessabin), will let us solve that problem. We'll see exactly how in the rest of
this post, but before we go there, we need to configure our project properly.

The first thing to do is to add it as a dependency in the `build.sbt` file. We must also add macro support, as some
of shapeless' magic rely on that:

```scala
scalaVersion := "2.11.7"

libraryDependencies += "com.chuusai" %% "shapeless" % "2.2.5"

addCompilerPlugin("org.scalamacros" % "paradise" % "2.1.0" cross CrossVersion.full)
```

Finally, we'll bring shapeless' classes in scope:

```scala
import shapeless._
```

Now that this is done, we can go back to deriving type class instances for case classes automatically.

# Deriving instances for case classes
If you recall, we had two problems with case classes: abstracting over the number of fields and, once provided with
the right values for each field, automatically creating instances of a case class.

## Abstracting over arity
First, let's define that fancy word we just used: _arity_. In this context, it's simply the number of fields a case
class has.

Case classes can have any arity (well, any up to 22). The problem is that Scala does not really let you describe such
a thing in a generic manner - so far, we've had to declare one type class instance per case class arity, which is rather
a lot of duplicated code.

What we need, then, is a way to write a type that encompasses all possible arities.

One way of looking at a type class is as an ordered list of fields. Take, for example, the following class:

```scala
case class Person(name: String, age: Int, single: Boolean)
```

You can see that we could almost describe it as "a `String`, followed by an `Int`, followed by a `Boolean`". This looks
a lot like a structure that we're very familiar with: a simple, but one in which cells don't all have to be of the same
type. If we were to be capable of declaring such a type, a large part of the problem would be dealt with: lists have
no fixed arity, so a list of heterogenous types looks like a fine way to represent the values that are used to build
a case class.

And shapeless declares exactly that type: `HList`, which stand for heterogenous list.

### `HList`
`HList` is a clever type that's worth explaining.



* a cons cell `::[A, B]`, where `A` is the type of the value contained in the cell and `B` is the type of the rest of
  the list (constrained to be a subtype of `HList`).
* `HNil`, the empty `HList`.

That is, a `HList` is either a value followed by another `HList`, or the empty `HList`.

And the type of an `HList` can be declared in a relatively pleasant fashion thanks to a somewhat obscure Scala: we can
use infix notation when declaring types. That is, `::[A, B]` is strictly equivalent to `A :: B`.

Our previous example, then, would be of type `String :: Int :: Boolean :: HNil`. Let's declare a value of that type
to make sure this works:

```scala
scala> val me: String :: Int :: Boolean :: HNil = "Nicolas" :: 37 :: false :: HNil
me: String :: Int :: Boolean :: shapeless.HNil = Nicolas :: 37 :: false :: HNil
```

By using infix notation, we can write our previous type as `String :: Int :: Boolean :: HNil`. And that certainly looks
like something we could write a `RowDecoder` instance for. Let's start easy by making an instance for the specific type
we're interested in:

_TODO: more details about creating HList instances_

```scala
implicit def hlist(implicit ds: CellDecoder[String], di: CellDecoder[Int], db: CellDecoder[Boolean])
  : RowDecoder[String :: Int :: Boolean :: HNil] =
  rowDecoder(ss => ds.decode(ss(0)) :: di.decode(ss(1)) :: db.decode(ss(2)) :: HNil)
```

By now, you should realise that there's a lot of things we can improve here. To begin with, there really isn't any
justification for hard-coding the cell types. We should really make our function generic.

This is fairly simple, we just need to replace our concrete types by type parameters:

```scala
implicit def hlist[A, B, C](implicit da: CellDecoder[A], db: CellDecoder[B], dc: CellDecoder[C])
  : RowDecoder[A :: B :: C :: HNil] = rowDecoder(ss => da.decode(ss(0)) :: db.decode(ss(1)) :: dc.decode(ss(2)) :: HNil)
```

Better, but the whole point of using `HList` was to be able to abstract over arity, which we absolutely have not done
here: our decoder hard-codes the `HList` length to 3.

_TODO: explain how to come up with hlist_

```scala
implicit def hlist[H, T <: HList](implicit dh: CellDecoder[H], dt: RowDecoder[T]): RowDecoder[H :: T] = rowDecoder(ss =>
  dh.decode(ss.head) :: dt.decode(ss.tail)
)
```

We now have something that looks like it should work (it won't, though. Can you see why?). Let's try and parse
actual data and see what happens:

```scala
scala> parseCsv[String :: Int :: Boolean :: HNil](Source.fromString("Nicolas,37,false\nMatt,24,true")).toList
<console>:26: error: could not find implicit value for parameter da: RowDecoder[String :: Int :: Boolean :: shapeless.HNil]
       parseCsv[String :: Int :: Boolean :: HNil](Source.fromString("Nicolas,37,false\nMatt,24,true")).toList
                                                 ^
```

The error message isn't terribly helpful, but we can work this out. When looking for an implicit
`RowDecoder[String :: Int :: Boolean :: HNil]`, the compiler will find `hlist` which looks like it might be able to
generate one. For that to work out, it needs a `CellDecoder[String]`, which we have provided earlier, and a
`RowDecoder[Int :: Boolean :: HNil]`. By following the same steps, we find that we need a `RowDecoder[Boolean :: HNil]`,
then a `RowDecoder[HNil]` - which we have not provided.

Another way of reaching that conclusion is to realise that `hlist` violates one of the first rules of recursive
functions: it has no termination case. For an `HList`, that's the empty list, or `HNil`.

Let's implement the required `RowDecoder[HNil]`, which will retur `HNil` whatever the input:

```scala
implicit val hnil: RowDecoder[HNil] = rowDecoder(_ => HNil)
```

And we can now parse our previous input as expected:

```scala
scala> parseCsv[String :: Int :: Boolean :: HNil](Source.fromString("Nicolas,37,false\nMatt,24,true")).toList
res1: List[String :: Int :: Boolean :: shapeless.HNil] = List(Nicolas :: 37 :: false :: HNil, Matt :: 24 :: true :: HNil)
```


We now have a `RowDecoder[HList]` instance which allows us to decode CSV rows into a heterogenous list of any types,
provided these types have a `CellDecoder`. All we need is a way to turn these lists into case classes, and we'll have
achieved our goal.

## Turning `Hlist`s into case classes
shapeless comes with the wonderfully useful `Generic` type class, and its more pleasant to read and write companion
`Generic.Aux`.

Given two concrete types `A` and `B`, if you have an instance of `Generic.Aux[A, B]`, you can turn any value of type `A`
into one of type `B`, and vice-versa. In our case, if we managed to retrieve an instance of `Generic.Aux` for
a case class and the corresponding `HList`, we'd essentially be done.

```scala
implicit def caseClass[A, L <: HList](implicit gen: Generic.Aux[A, L], dl: RowDecoder[L]): RowDecoder[A] =
  rowDecoder(ss => gen.from(dl.decode(ss)))
  ```

```scala
scala> parseCsv[Person](Source.fromString("Nicolas,37,false\nMatt,24,true")).toList
res2: List[Person] = List(Person(Nicolas,37,false), Person(Matt,24,true))
```

# Deriving instances for ADTs

_TODO, everything_

# What next?
Our [next task](/2015/12/01/tcgu-part-4.html) will be to is to work on packaging these default implementations in a way
that makes them as easy to access to developers as possible, without conflicting with whatever custom implementations
they might have declared.
