---
title: Type Classes from the Ground Up - Amelioration
tags: scala
---
In this post, we'll be talking about the various tools and helper functions that are usually expected when working with
type classes, and exploring libraries that automate most of the work of writing these tools.

<!--more-->

See the [introduction](/2015/11/21/tcgu-part-0.html) for more context and a table of content for the whole series.


# What we've done so far
In the previous posts, we've come up with two type classes, `RowDecoder` and `CellDecoder`, used to parse CSV rows
and cells, respectively:

```scala
trait CellDecoder[T] {
  def decode(s: String): T
}

trait RowDecoder[T] {
  def decode(row: IndexedSeq[String]): T
}
```

These type classes are used by a `parseCsv` function that turns CSV data into an iterator of whatever type we want to
represent each row as:

```scala
import scala.io.Source

def parseCsv[A](input: Source)(implicit da: RowDecoder[A]): Iterator[A] =
  input.getLines.map(r => da.decode(r.split(",")))
```

We've also defined various instances for `RowDecoder` and `CellDecoder`. I won't repeat them all here, but here are a
few:

```scala
// Helper function for creating cell decoder instances.
def cellDecoder[A](f: String => A): CellDecoder[A] = new CellDecoder[A] {
  override def decode(s: String) = f(s)
}

// Helper function for creating row decoder instances.
def rowDecoder[A](f: IndexedSeq[String] => A): RowDecoder[A] = new RowDecoder[A] {
  override def decode(row: IndexedSeq[String]) = f(row)
}

// A few cell decoders.
implicit val intDecoder = cellDecoder(_.toInt)
implicit val stringDecoder = cellDecoder(identity)
implicit val booleanDecoder = cellDecoder(_.toBoolean)
implicit def optDecoder[A](implicit da: CellDecoder[A]) =
  cellDecoder(s => if(s.isEmpty) None else Some(da.decode(s)))

// A few row decoders.
implicit def row1Decoder[A](implicit da: CellDecoder[A]) = rowDecoder(r => da.decode(r(0)))
def caseClass2Decoder[A0, A1, C](f: (A0, A1) => C)(i0: Int, i1: Int)(implicit d0: CellDecoder[A0], d1: CellDecoder[A1]): RowDecoder[C] =
  rowDecoder(row => f(d0.decode(row(i0)), d1.decode(row(i1))))
implicit def tuple2Decoder[A0, A1](implicit d0: CellDecoder[A0], d1: CellDecoder[A1]): RowDecoder[(A0, A1)] =
  caseClass2Decoder(Tuple2.apply[A0, A1])(0, 1)
```

We're going to work on making all this easier, less cumbersome to manipulate.


# CsvInput
Before that though, we need to create a new type class to really tie things together. We know how to parse cells and
rows, but we have yet to write a generic way to turn anything that contains CSV data into an iterator on rows - we've
hard-coded parsing to `scala.io.Source` so far, which seems like a bit of a shame when the whole point of this series
was to come up with a way to decouple functionality from implementation.

We can declare a new `CsvInput[T]` type class that turns any instance of `T` into something that can be read as CSV
data. Our `parseCsv` function knows how to work with `Source`, so why not simply have `CsvInput` turn values
into instances of `Source`?

```scala
trait CsvInput[T] {
  def asSource(t: T): Source
}
```

This would allow us to rewrite `parseCsv` as:

```scala
def parseCsv[A, B](input: B)(implicit da: RowDecoder[A], cb: CsvInput[B]): Iterator[A] =
  cb.asSource(input).getLines.map(r => da.decode(r.split(",")))
```

But if you think about it, we've now found a convenient place to put `parseCsv`: it's more idiomatic for it to be
method of `CsvInput` rather than an unbound function. Let's modify `CsvInput` accordingly:

```scala
trait CsvInput[T] {
  def asSource(t: T): Source
  def parseCsv[A](t: T)(implicit da: RowDecoder[A]): Iterator[A] =
    asSource(t).getLines.map(row => da.decode(row.split(",")))
}
```

Good. In the future, when we need to parse a string as CSV, we'll simply need to use the corresponding `CsvInput`
instance, which we'll write just now:

```scala
implicit val stringInput = new CsvInput[String] {
  override def asSource(s: String) = Source.fromString(s)
}
```

This is where things get a little weird though. How *do* we summon an instance of `CsvInput[String]`? So far, all of
our type class instances were passed to us as implicit parameters and we relied on the compiler to work everything out
for us.

It turns out Scala has a somewhat verbose solution: the `implicitly` function, which summons an implicit instance of its
type parameter if it can find one and fails to compile otherwise. In our case, it'd work like this:

```scala
scala> implicitly[CsvInput[String]].parseCsv[(Int, Int)]("1,2\n3,4").toList
res9: List[(Int, Int)] = List((1,2), (3,4))
```

This works just as expected, but it doesn't really feel like a win, does it? That's actually *more* work to call then
our old `parseCsv` function, and the syntax is a bit brutal, mixing type and value parameters all over the place.
Moreover, `implicitly` has a runtime cost, even if a tiny one - however simple its implementation, it's still a method
call.

# Summoning implicit instances
A very common (and expected) pattern is to declare an `apply` method in a type class' companion object that summons
implicit instances - a sort of specialised version of `implicitly`. That is, given a type class `F[T]`, the companion
object of `F` will have a method `def apply[T]: F[T]`.

This is fairly simple to implement, and identical for all type classes:

```scala
object CsvInput {
  def apply[A](implicit ia: CsvInput[A]): CsvInput[A] = ia
}
```

This is actually pretty trivial: when called, it will only compile if an implicit instance of `CsvInput` is found for
its type parameter. All it then does is return that value.

Thanks to the usual `apply` syntactic sugar, we can now rewrite our string parsing call as follows:

```scala
scala> CsvInput[String].parseCsv[(Int, Int)]("1,2\n3,4").toList
res10: List[(Int, Int)] = List((1,2), (3,4))
```

This can be a bit odd to read, and indeed tends to confuse IDEs entirely, but is a nice and accepted way of making
type class code acceptably terse.

In this specific case though, we can go one step further with operators.

# Operators
A common pattern for type classes, and a good solution for our last problem, is to enhance types that have instances
of a given type class with helper functions to make them more convenient to use. These functions are usually called
_operators_ or _syntax_.

Given a type class `F[T]`, there are two kinds of operators: those that operate on a `T` and those that return one. I do
not know of an official vocabulary for these, so I'll be calling the former _transformation_ operators and the later
_creation_ ones. If widely accepted terms already exists, I'd love to hear about them and amend this post accordingly.

## Implicit conversion
Both kinds of operators rely on the same mechanism: implicit conversion, a Scala feature that allows the compiler to
transform types implicitly when it can. That's generally something I try to steer clear of - it's hard to trust or
reason about types when the compiler can change them behind your back - but type class operators is one of the few cases
I feel it's desirable.

To simplify things, if the compiler finds a value of type `A` where it expects one of type `B`, but there is a function
`A => B` marked as implicit, it will silently apply it and accept the code as valid. If you mark a class as implicit,
then its main constructor will be considered to be an implicit function. There are some restrictions (only one
non-implicit parameter, ...), but they're not terribly important to what we're trying to achieve here.

Here's a simple example:

```scala
scala> implicit def strToInt(s: String): Int = Integer.parseInt(s)
strToInt: (s: String)Int

scala> val i: Int = "123"
i: Int = 123
```

`i` is an int, but its value is declared to be a string. Luckily, the compiler finds an implicit `String => Int`
function, `strToInt`, and applies it silently.

More interesting to our use case, if the compiler finds a method called on a type that doesn't declare it, it'll look
for an implicit conversion to a type that does declare it:

```scala
scala> implicit def intToStr(i: Int): String = i.toString
intToStr: (i: Int)String

scala> 123.substring(0, 2)
res11: String = 12
```

`123` is of type int, which does not actually have a `substring` method. The compiler finds `intToStr`, however, which
allows it to turn any int value to a string implicitly, and strings do have a `substring` method.

Let's take a final example, one with an implicit class constructor, to make it clear how that works:

```scala
scala> implicit class StringAsInt(str: String) {
     |   def asInt: Int = Integer.parseInt(str)
     | }
defined class StringAsInt

scala> "123".asInt
res12: Int = 123
```
`"123"` is of type string, which does not have an `asInt` method. The compile finds `StringAsInt`'s constructor,
however, which allows it to turn any string value into a `StringAsInt` value, which has an `asInt` method.


## Transformation operators
Transformation operators are methods added to the type to which a type class relates - in the case of `CsvInput[T]`, for
instance, a transformation operator would be a new method on type `T`.

`CsvInput[T]` has a `parseCsv` method that takes an `T` as a parameter. That's usually a good sign that it can be
grafted as a new method on `T`. We'll call it `asCsvRows`, and it'll let us transform any `T` that has an instance of
`CsvInput` into an iterator on rows:

```scala
implicit class CsvInputOps[T](t: T)(implicit it: CsvInput[T]) {
  def asCsvRows[A](implicit da: RowDecoder[A]): Iterator[A] = it.parseCsv(t)
}
```

With that in place, when the `asCsvRows` method is called on a value whose type doesn't declare it but has an instance
of `CsvInput`, the compiler will know to turn it into an instance of `CsvInputOps`. Since we already have a `CsvInput`
instance in place for strings, we can rewrite our string parsing call in the following, much terser syntax:

```scala
scala> "1,2\n3,4".asCsvRows[(Int, Int)].toList
res13: List[(Int, Int)] = List((1,2), (3,4))
```

Note that our implementation of `CsvInputOps` is clearly suboptimal - we could easily turn it into a value class, for
example, to get rid of the runtime cost of boxing. There's little point in doing so, however, when we'll soon introduce
tools to automate the creation of these operators for us.

## Creation operators
Given a type class `F[T]`, a creation operator is one that returns a value of type `T` rather than operate on an
existing one. This kind of operator is a bit less common, but still quite useful.

The `decode` method of `CellDecoder` looks like it could benefit from being turned into a creation operator: it takes
a string and returs a `T`, and could easily be mapped to an enhancement on string. As before, this is achieved through
an implicit class:

```scala
implicit class CellDecoderOps(s: String) {
  def asCsvCell[A](implicit da: CellDecoder[A]): A = da.decode(s)
}
```

And with that, we can now call the `asCsvCell` method on strings, provided the type parameter has an instance of
`CellDecoder`:

```scala
scala> "123".asCsvCell[Int]
res14: Int = 123
```

# Context bounds
Now that we have made using type classes mucher terser and simpler, let's revisit some of our existing instances. In
particular, let's see if we can make `caseClass2Decoder` a bit terser:

```scala
def caseClass2Decoder[A0, A1, C](f: (A0, A1) => C)(i0: Int, i1: Int)(implicit d0: CellDecoder[A0], d1: CellDecoder[A1]): RowDecoder[C] =
  rowDecoder(row => f(d0.decode(row(i0)), d1.decode(row(i1))))
```

Since we now have a convenient operator for `decode`, we can rewrite it as:

```scala
def caseClass2Decoder[A0, A1, C](f: (A0, A1) => C)(i0: Int, i1: Int)(implicit d0: CellDecoder[A0], d1: CellDecoder[A1]): RowDecoder[C] =
  rowDecoder(row => f(row(i0).asCsvCell[A0], row(i1).asCsvCell[A1]))
```

But now, if you pay attention to the code, you'll notice that we're not even using our `d0` and `d1` implicit
parameters. Well, we're not using them explicitly anyway, but the compiler does need them in order to work out how
to interpret `asCsvCell`.

For parameters that we're not actually referencing, they sure represent a large amount of code. Luckily, Scala has
special syntax to make this much terser: _context bounds_. This is what it looks like:

```scala
def caseClass2Decoder[A0: CellDecoder, A1: CellDecoder, C](f: (A0, A1) => C)(i0: Int, i1: Int): RowDecoder[C] =
  rowDecoder(row => f(row(i0).asCsvCell[A0], row(i1).asCsvCell[A1]))
```

Pay attention to the type parameters, where both `A1` and `A2` have been annotated with `: CellDecoder`. This causes
the Scala compiler to add implicit parameters of types `CellDecoder[A1]` and `CellDecoder[B2]` to `caseClass2Decoder`.

These parameters aren't named, though. If we needed to reference them explicitly, we'd need to either user `implicitly`
or our special `CellDecoder.apply` - it's debatable whether using context bound in this case would be a good idea.
Luckily, we don't actually need to know how the implicit parameters are called, just that they exist to be picked up
by the compiler.

The benefits of context bounds are even more obvious with `tuple2Decoder`. Recall that, in the previous post, we noted
how the implicit parameters were not used, at least not explicitly. This is how we should write such functions from now
on:

```scala
implicit def tuple2Decoder[A0: CellDecoder, A1: CellDecoder]: RowDecoder[(A0, A1)] =
  caseClass2Decoder(Tuple2.apply[A0, A1])(0, 1)
```

# Simulacrum
A lot of the things we've just discussed make life much easier for users of our type classes, but required a
non-negligible amount of work to put together. Luckily however, there's a solution to automate most of it: the excellent
[Simulacrum](https://github.com/mpilquist/simulacrum), by Michael Pilquist.

## What it does
Simulacrum uses simple annotations to generate a lot of the boilerplate associated with the various improvements we
brought to our type classes. We'll quickly go through them to show what their purpose is, but this is not meant to be
a complete Simulacrum documentation - the project's [Readme](https://github.com/mpilquist/simulacrum) does that better
than I ever could.

### `@typeclass`
Use the `@typeclass` annotation to mark a class as type class. This will generate:

* an `apply` method on the companion object that lets you summon implicit instances easily.
* an `Ops` and `AllOps` traits in the companion object that declare all transformation operators Simulacrum
  could identify.
* a `ToTypeclassNameOps` trait that provides implicit conversion to `Ops`.
* an `ops` object in the companion object that provides implicit conversion to `AllOps`.

The difference between `Ops` and `AllOps` is that the former only contains operators declared by your type class, while
the later will also contain those declared by whatever type class it's a subtype of.

Let's illustrate this with a concrete example: `CsvInput`.

```scala
@simulacrum.typeclass
trait CsvInput[T] {
  def asSource(t: T): Source
  def parseCsv[A](t: T)(implicit da: RowDecoder[A]): Iterator[A] =
    asSource(t).getLines.map(row => da.decode(row.split(",")))
}

// Since we've just recreated CsvInput, we need to re-declare known instances.
implicit val stringInput = new CsvInput[String] {
  override def asSource(s: String) = Source.fromString(s)
}
```

Let's first make sure that our implicit instance summoning mechanism works as expected:

```scala
scala> CsvInput[String].parseCsv[Int]("1\n2").toList
res17: List[Int] = List(1, 2)
```

That works, now on to operators. `parseCsv` takes a parameter of type `A` and should have been turned into a
transformation operator:

```scala
scala> import CsvInput.ops._
import CsvInput.ops._

scala> "1\n2".parseCsv[Int].toList
res18: List[Int] = List(1, 2)
```

On the one hand, this is good: the operator does exist. On the other hand, this is not a very idiomatic name for it: the
string `"1\n2"` doesn't actually parse CSV, it's parsed *as* CSV.

Another issue is that `asSource` looks a lot like a candidate for being turned into operator, and was, in fact, turned
into one:

```scala
scala> "1\n2".asSource
res19: scala.io.Source = non-empty iterator
```

But the fact that our parsing mechanism relies on `Source` is just plumbing, not something we want the rest of the
world to use directly. We would much rather not have an operator for that.


### `@op`
Let's start by tackling our first issue. Simulacrum provides the `@op` annotation to let us to control how a method is
turned into an operator. It takes a compulsory parameter, the name we want to end up with, an an optional boolean one
to turn our operator into an alias - if set to `true`, both the original name and the annotation parameter will be used.

We don't really want to have `parseCsv` available as an operator at all, so we won't declare it as an alias. On the
hand, we want to give the corresponding operator a more idiomatic name - `asCsvRows`, say.

```scala
@simulacrum.typeclass
trait CsvInput[T] {
  def asSource(t: T): Source

  @simulacrum.op("asCsvRows")
  def parseCsv[A](t: T)(implicit da: RowDecoder[A]): Iterator[A] =
    asSource(t).getLines.map(row => da.decode(row.split(",")))
}

// Since we've just recreated CsvInput, we need to re-declare known instances.
implicit val stringInput = new CsvInput[String] {
  override def asSource(s: String) = Source.fromString(s)
}
```

Let's first make sure this created the expected operator:

```scala
scala> import CsvInput.ops._
import CsvInput.ops._

scala> "1\n2".asCsvRows[Int].toList
res22: List[Int] = List(1, 2)
```

We also want to confirm that the `parseCsv` operator does not exist anymore:

```scala
scala> "1\n2".parseCsv[Int].toList
<console>:51: error: value parseCsv is not a member of String
       "1\n2".parseCsv[Int].toList
              ^
```

### `@noop`
Our last issue is that we want to get rid of the `asSource` operator. Simulacrum has the `@noop` annotation for that
specific purpose:

```scala
@simulacrum.typeclass
trait CsvInput[T] {
  @simulacrum.noop
  def asSource(t: T): Source

  @simulacrum.op("asCsvRows")
  def parseCsv[A](t: T)(implicit da: RowDecoder[A]): Iterator[A] =
    asSource(t).getLines.map(row => da.decode(row.split(",")))
}

// Since we've just recreated CsvInput, we need to re-declare known instances.
implicit val stringInput = new CsvInput[String] {
  override def asSource(s: String) = Source.fromString(s)
}
```

And, as expected, trying to use `asSource` as an operator now fails:

```scala
scala> "1\n2".asSource
<console>:54: error: value asSource is not a member of String
       "1\n2".asSource
              ^
```

### Providing access to operators
We've seen that Simulacrum takes care of providing access to a single type class' operators through its companion
object's nested `ops` object. For example, all one needs to use all `CsvInput` operators is to import `CsvInput.ops._`.

Often however, we want to bring in all operators for all type classes in a library. Simulacrum does not (cannot)
automate this for us, but it does give us all we need with the companion object's nested `ToXXXOps` trait. A
common pattern is for a library to contain an `ops` object that extends each such trait for all type classes in the
library.

Let's first annotate `CellDecoder` and `RowDecoder` properly, so that we have the necessary traits for all our type
classes:

```scala
@simulacrum.typeclass
trait CellDecoder[T] {
  def decode(s: String): T
}

@simulacrum.typeclass
trait RowDecoder[T] {
  def decode(row: IndexedSeq[String]): T
}
```

We can now declare our `ops` object and have it extend all the relevant `ToXXXOps` traits:

```scala
object ops extends CsvInput.ToCsvInputOps       with
                   CellDecoder.ToCellDecoderOps with
                   RowDecoder.ToRowDecoderOps
```

From now on, users of our library need only import `ops._` to be able to use all the operators we defined.



## What it doesn't do
There are a few things that Simulacrum doesn't do, or does in ways that can be improved on.

The first one is that, at the time of writing, Simulacrum doesn't generate creation operators at all. This has been
discussed in the project's [Gitter channel](https://gitter.im/mpilquist/simulacrum?at=565b62f5c3d575114e6c9fe4) and
[might be adressed](https://github.com/mpilquist/simulacrum/issues/45) in the future.

Another issue is that most of the nice functions and operators that Simulacrum generates for us have an unnecessary
runtime cost.

The companion object's `apply` method, for instance, is still a method call - a very small, very quick method call,
but not as cheap as just using the correct instance explicitly. [Imp](https://github.com/non/imp) is a project that
improves on this, but I don't think it's possible to use it and Simulacrum at the same time.

Finally, operators have a non-negligible runtime cost, as they require wrapping values in types that provide our
enhancements. Another project, [Machinist](https://github.com/typelevel/machinist), aims to fix that, but it's currently
not compatible with Simulacrum (or at least I couldn't work out how to reap the full benefits of both).


## What it will become
Having leveled these criticisms at Simulacrum, it would be dishonnest not to point out that they are well known and
being adressed. In fact, all the projects we mentionned in the previous section (as well as a few others) are being
brought together as a single one, [Typeclassic](https://github.com/typelevel/typeclassic/), which will hopefully
eventually turn into the one type class framework to rule them all.

# What next?
At this point, we're starting to be pretty comfortable with type classes: we know what problem they address, how to
create our own and let the compiler to a lot of the hard work for us, and how to make them pleasant and intuitive to
use.
