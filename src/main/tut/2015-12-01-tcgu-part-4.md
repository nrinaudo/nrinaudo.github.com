---
title: Type Classes from the Ground Up - Resolution
tags: scala
---

_WORK IN PROGRESS: this section still needs extensive work and might get scrapped / rewritten in its entirety. It's here
more to motivate me to complete it than to be read as a reliable explanation. Suggestions are welcome, though._


In this fourth post, we'll try to gain a better understanding of how implicits are resolved, and to use that knowledge to
organise our default type class instances in ways that makes them as convenient as possible to use.

<!--more-->

See the [introduction](/2015/11/21/tcgu-part-0.html) for more context and a table of content for the whole series.


# What we've done so far

In the previous posts, we've come up with two type classes, `RowDecoder` and `CellDecoder`, used to parse CSV rows and
cells, respectively:

```tut:silent
trait CellDecoder[T] {
  def decode(s: String): T
}

trait RowDecoder[T] {
  def decode(row: IndexedSeq[String]): T
}
```

These type classes are used by a parseCsv function that turns CSV data into an iterator of whatever type we want to
represent each row as:

```tut:silent
import scala.io.Source

def parseCsv[A](input: Source)(implicit da: RowDecoder[A]): Iterator[A] =
  input.getLines.map(r => da.decode(r.split(",")))
```

We've then declared a certain amount of instances, such as a `CellDecoder` for ints and a `RowDecoder` for tuples:

```tut:silent
implicit val intDecoder = new CellDecoder[Int] {
  override def decode(s: String): Int = s.toInt
}

implicit def tuple2Decoder[A](implicit da: CellDecoder[A]) = new RowDecoder[(A, A)] {
  override def decode(ss: IndexedSeq[String]): (A, A) = (da.decode(ss(0)), da.decode(ss(1)))
}
```

These instances can be considered reasonnable defaults: while we could certainly come up with different ways to encode
integers (in base 16, say), defaulting to the more human readable base 10 sounds like a safe bet.

# Packaging default instances
Ideally, such default instances would be available immediately, without any hoop to jump through. And Scala has a
mechanism for that: the _implicit scope_, one of the places the compiler will look at when trying to resolve implicit
values.

A full description can be found in
[the specifications](http://scala-lang.org/files/archive/spec/2.11/07-implicits.html#implicit-parameters), but we can
use a simplified definition: given a type `T`, its implicit scope will be its companion object as well as those of all
types that are associated with it.

For a type `F[T]`, then, the implicit scope would be the companion object of `F` and that of `T`.

For our use case, it means that whenever the compiler is looking for, say, a `CellDecoder[Boolean]`, it will look into
the companion object of `CellDecoder` and that of `Boolean`. We can't really do much with the companion object of
`Boolean`, but that of `CellDecoder` is a perfect place for our default instances. Any `CellDecoder` instance we
declare there will be immediately available to anyone, without requiring imports.

Let's verify this. We first need to declare an implicit `CellDecoder[Boolean]` in `CellDecoder`'s companion object.

```tut:silent
object CellDecoder {
  // Makes creating instances of CellDecoder easier.
  def apply[A](f: String => A): CellDecoder[A] = new CellDecoder[A] {
    override def decode(s: String) = f(s)
  }

  implicit val booleans: CellDecoder[Boolean] = CellDecoder(_.toBoolean)
}
```

We can now parse CSV data that contains boolean values:

_Due to current limitations in the Scala REPL, the code below is not actually compiled and executed._

```scala
parseCsv[(Boolean, Boolean)](Source.fromString("true,true\nfalse,true")).toList
```

And we were able to do so without having to import or declare anything, the compiler was able to work everything out
without any help from us.

But while this exactly what we set out to do, it raises one question: what happens when the default instance doesn't
have the right behaviour for a specific problem?

# Overriding default instances
Default instances are useful in that, if well thought out, they will be sufficient the vast majority of the time. There
are however cases where we want to override them: what if we must parse CSV data in which booleans are not encoded as
the default `true` and `false` but rather `yes` and `no`?

This brings us to the other place the compiler looks for implicit values: the current scope. Implicit values found
there have the highest priority - that is, if an implicit value is found in the current scope, the implicit scope will
be ignored entirely.

Overriding default instances is done simply by bringing the desired replacement in scope, either through an import or
a local declaration. For example:

```tut:silent
implicit val yesNoBool = CellDecoder(s => if(s == "yes") true else false)
```

And we can now parse booleans as expected:

```tut
parseCsv[(Boolean, Boolean)](Source.fromString("yes,yes\nno,yes")).toList
```

# TODO

* implicit instances priority (`LowPriorityRowDecoders`).
* implementing type classes from outside the project.
  * for your own types
  * for existing types (bridges between API).



# What next?
The [next problem](/2015/12/13/tcgu-part-5.html) we're going to tackle is how verbose and sometimes cumbersome our use
of type classes has been so far. The type signatures of our various decoders is annoyingly long, for example, and our
`parseCsv` function is not very idiomatic - we're more used to such functions being methods than unbound functions.
