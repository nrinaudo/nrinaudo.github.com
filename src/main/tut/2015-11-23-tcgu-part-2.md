---
title: Type Classes from the Ground Up - Composition
tags: scala
---
In this second post, we'll be tackling the mechanism by which simple type class instances combine to create much more
complex and useful ones.

<!--more-->

See the [introduction](/2015/11/21/tcgu-part-0.html) for more context and a table of content for the whole series.

# What we've done so far
In the [previous post](/2015/11/21/tcgu-part-1.html), we ended up creating a simple type class, `CellDecoder`, used to
add CSV cell decoding capabilities to existing types:

```tut:silent
trait CellDecoder[T] {
  def decode(s: String): T
}
```

This is then used by our `parseCsv` method:

```tut:silent
import scala.io.Source

def parseCsv[A](input: Source)(implicit da: CellDecoder[A]): Iterator[IndexedSeq[A]] =
  input.getLines.map(_.split(",").map(da.decode))
```

And while this is already pretty nice, we've realised that it didn't help us much with heterogenous types, such as in:

```tut
val input = "1,Nicolas,true\n2,Jessica,false\n3,Matt,false"
```

This would best be parsed as, say, a tuple of type `(Int, String, Boolean)`, or maybe even a
`case class User(id: Int, name: String, fictional: Boolean)`.

# Row decoders
What we're trying to achieve, then, is to parse an entire row as a single type, rather than just individual cells. And
logically, we should try approaching this the same way we did cells: with a dedicated type class, which we'll call
`RowDecoder`.

So what would a `RowDecoder` do? well, just like a `CellDecoder` takes the raw content of a cell and turns it into a
better typed value, a `RowDecoder` should be capable of taking the raw content of a row and turn it into whatever type
we need. Since the raw content of a row is an `IndexedSeq[String]`, our trait could look something like:

```tut:silent
trait RowDecoder[T] {
  def decode(row: IndexedSeq[String]): T
}
```

We need to rework `parseCsv` with this type class in mind: instead of manually mapping over each cell in a row, we just
need to call `RowDecoder.decode` on each row.

```tut:silent
def parseCsv[A](input: Source)(implicit da: RowDecoder[A]): Iterator[A] = input.getLines.map(r => da.decode(r.split(",")))
```

And now, in order to make sure everything works, let's create the decoder for our `(Int, String, Boolean)` type:

```tut:silent
implicit val tupleDecoder = new RowDecoder[(Int, String, Boolean)] {
  override def decode(row: IndexedSeq[String]) = (row(0).toInt, row(1), row(2).toBoolean)
}
```

This is fairly simple, just parse each cell into the expected type and stick it at the right index in a new tuple.

Note that, just in the previous post, we're knowingly ignoring error handling altogether in order to keep things clear
and on point.

Now that we have all the pieces, we can just call `parseCsv` with the correct type parameter:

```tut
parseCsv[(Int, String, Boolean)](Source.fromString(input)).toList
```

The implict parameter resolution is trivial: look for a value of type `RowDecoder[(Int, String, Boolean)]`, find
`tupleDecoder`, use that.

And we get exactly what we set out to do: we now have a generic way of turning raw CSV rows into more specific,
immediatelly useful types. But this still isn't quite satisfying: if you look at `tupleDecoder`'s code, you'll notice
that we hard-coded the bits that turn single CSV cells into more useable values. This seems like a shame, when we spent
the whole of the first post in this series designing a generic CSV cell decoding mechanism...

# Assembling RowDecoder instances
Our goal is now to use `CellDecoder` instances to decode each cell, and let `tupleDecoder` assemble them in the final
value. The first task is to write the required `CellDecoder` instances for ints, strings and booleans:

```tut:silent
// Makes creating CellDecoder instances easier
def cellDecoder[A](f: String => A): CellDecoder[A] = new CellDecoder[A] {
  override def decode(s: String): A = f(s)
}

implicit val intDecoder:     CellDecoder[Int]     = cellDecoder(_.toInt)
implicit val stringDecoder:  CellDecoder[String]  = cellDecoder(identity)
implicit val booleanDecoder: CellDecoder[Boolean] = cellDecoder(_.toBoolean)
```

Now that we have these instances, we can rewrite `tupleDecoder` to use them:

```tut:silent
implicit val tupleDecoder = new RowDecoder[(Int, String, Boolean)] {
  override def decode(row: IndexedSeq[String]) =
    (intDecoder.decode(row(0)), stringDecoder.decode(row(1)), booleanDecoder.decode(row(2)))
}
```

But that's not quite satisfying yet - while we're using `CellDecoder` instances, we've hard-coded *which* instances.
We can imagine situations where booleans are not encoded as `true` and `false` but as `yes` and `no`, for example, which
`tupleDecoder` would fail to parse. Better to make these `CellDecoder` values parameters of `tupleDecoder` (which
will need to be turned into a function). Let's also make the parameters implicit, so that we can just rely on the
default implementations when we don't want bespoke behaviour:

```tut:silent
implicit def tupleDecoder(implicit di: CellDecoder[Int], ds: CellDecoder[String], db: CellDecoder[Boolean]) =
  new RowDecoder[(Int, String, Boolean)] {
    override def decode(row: IndexedSeq[String]) = (di.decode(row(0)), ds.decode(row(1)), db.decode(row(2)))
  }
```

And this is better: we don't have to implement cell decoding in `tupleDecoder`, just ask to be provided with a means of
doing so. And it works as expected:

```tut
parseCsv[(Int, String, Boolean)](Source.fromString(input)).toList
```

The implicit resolution in this case is a bit more convoluted, but perfectly understandable:

* look for a value of type `RowDecoder[(Int, String, Boolean)]`. None matches that directly, but `tupleDecoder`
  is capable of generating one *and* is marked as implicit, check whether we can call it.
* `tupleDecoder` needs implicit values of types `CellDecoder[Int]`, `CellDecoder[String]` and `CellDecoder[Boolean]`
  to be able to generate the desired value. Look for them.
* Find `intDecoder`, `stringDecoder` and `booleanDecoder`, pass them to `tupleDecoder`, get the desired `RowDecoder`
  value, we're done.

But if you think about it, there is nothing here that needs to be int, string or boolean specific. In fact,
`tupleDecoder` never actually uses these types directly, only their associated type classes. This is a pretty strong
hint that `tupleDecoder` can be made polymorphic: when you don't use whatever information you can derive from knowing a
specific type, you can probably make that type generic.

Let us then make `tupleDecoder` polymorphic:

```tut:silent
implicit def tupleDecoder[A, B, C](implicit da: CellDecoder[A], db: CellDecoder[B], dc: CellDecoder[C]) =
  new RowDecoder[(A, B, C)] {
    override def decode(row: IndexedSeq[String]) = (da.decode(row(0)), db.decode(row(1)), dc.decode(row(2)))
  }
```


And just like that, we've written a decoder for all possible variations of
[`Tuple3`](http://www.scala-lang.org/api/current/index.html#scala.Tuple3). We might need to do a bit more work
to support specific _cell_ types, but as far as _row_ types are concerned, we will never need to write another line of
code to support rows that decode to `Tuple3[A, B, C]`, for all `A`, `B` and `C` types that have a cell decoder.

This is where type classes truly shine: they compose, and they do so implicitly. The remainder of this post will be
examples of cell and row decoders to really hammer that fact in.

# Examples of compound instances
## Collections
While we now have a much more powerful way of decoding rows, we seem to have lost the ability we had at the beginning of
this post to turn rows into sequences of a given type. And while that is true, we simply need to create a `RowDecoder`
instance for sequences. But we can do even better than that: why not write one for all collection types?

The trick is that the standard collection API itself uses type classes, one of which is
[`CanBuildFrom`](http://www.scala-lang.org/api/current/index.html#scala.collection.generic.CanBuildFrom): this allows us
to create [builders](http://www.scala-lang.org/api/current/index.html#scala.collection.mutable.Builder) for any
collection type.

With that in mind, we need to write a row decoder instance, but one that is a bit more complicated than we've done so
far, since it must involves two types:

* that of the values that will go in the resulting collection (and we need to know how to decode these values).
* that of the collection in which to put the values (and we need a `CanBuildFrom` for that type).

A possible implementation would be:

```tut:silent
import scala.collection.generic.CanBuildFrom

implicit def collectionDecoder[A, C[_]](implicit da: CellDecoder[A], cbf: CanBuildFrom[Nothing, A, C[A]]): RowDecoder[C[A]] =
  new RowDecoder[C[A]] {
    override def decode(ss: IndexedSeq[String]) = ss.foldLeft(cbf.apply())((out, s) => out += da.decode(s)).result()
  }
```

This function's signature might take a bit of explanations. The complexity lays with the `C` type parameter, as
there is nothing we do with `A` that you haven't seen before.

First, let's have a look at that weird type parameter, `C[_]`. This means that `C` is a _higher-kinded_ type: a type
that takes type parameters. And that makes sense: collections need a type parameter, that of the elements they contain.

Our `CanBuildFrom` parameter has a somewhat scary type signature as well, but it's fairly straightforward if we take it
one step at a time:

* According to the documentation, the first parameter is the type of the collection that requests a builder to be
  created: in our case, there is no such collection, we're creating a builder from scratch.
* The second parameter is the element type of the collection to be created: that's fairly simple, we know we want to
  create a collections of `A`s.
* The third parameter is the type of the collection to be created, which is fairly simple as well: the whole point of
  this is to create collections of type `C[A]`.

And to prove that this works, let's parse the same input we did in the previous post:

```tut
val input = "1,2,3\n4,5,6\n7,8,9"

parseCsv[IndexedSeq[Int]](Source.fromString(input)).toList
```

But we can now request more specific collection types if we want:

```tut
parseCsv[List[Int]](Source.fromString(input)).toList

parseCsv[Vector[Int]](Source.fromString(input)).toList
```

We can now decode CSV rows into any collection type, provided there is an implicit cell decoder for the its element
type. Think about this: we will never need to do any further work to support _any_ collection type from the standard
library, they're all supported thanks to these 4 lines of code.


## Data with alternatives
CSV data is often messy and not terribly bothered with correctness. A common occurence is for a cell to contain more
than one possible type. For example, how should we go about parsing the following data?

```tut
val input = "1,Nicolas,true\n2,Jessica,36"
```

Notice how the third cell is a boolean in one case and an int in the other. Well, Scala has a standard type for that:
[`Either`](http://www.scala-lang.org/api/current/index.html#scala.util.Either), where a value of type `Either[A, B]` is
either going to be a [`Left[A]`](http://www.scala-lang.org/api/current/index.html#scala.util.Left) or a
[`Right[B]`](http://www.scala-lang.org/api/current/index.html#scala.util.Right). And it turns out that writing a
`CellDecoder` for `Either` is not terribly complicated: we just need to request a way to parse both `A` and `B`, attempt
to parse as an `A` and, if that fails, try as a `B`:

```tut:silent
implicit def eitherCellDecoder[A, B](implicit da: CellDecoder[A], db: CellDecoder[B]): CellDecoder[Either[A, B]] =
  cellDecoder { s =>
    try {Left(da.decode(s))}
    catch { case _: Throwable => Right(db.decode(s)) }
  }
```

And now that we have a cell decoder for `Either`, there is no additional work required to parse our dodgy input, we
just need to let the compiler know what type we're expecting:

```tut
parseCsv[(Int, String, Either[Boolean, Int])](Source.fromString(input)).toList
```

The fun thing about this is that the compiler can work out recursive type class instances. The following, contrived
example automatically derives an instance for nested `Either`s:

```tut
val input = "1,Nicolas,true\n2,Jessica,36\n3,Matt,Joe"

parseCsv[(Int, String, Either[Boolean, Either[Int, String]])](Source.fromString(input)).toList
```


## Optional data
Another common occurence is optional values - cells that might contain data, but might not. For example:

```tut
val input = "1,Nicolas,true\n2,,false\n3,Matt,false"
```

The usual type to represent this is [`Option`](http://www.scala-lang.org/api/current/index.html#scala.Option), where a
value of type `Option[A]` will be either a [`Some[A]`](http://www.scala-lang.org/api/current/index.html#scala.Some) or
a [`None`](http://www.scala-lang.org/api/current/index.html#scala.None$). We can create a `CellDecoder` instance for
this fairly simply: empty cells map to `None`, non-empty ones to `Some`.

```tut:silent
implicit def optionCellDecoder[A](implicit da: CellDecoder[A]): CellDecoder[Option[A]] = cellDecoder { s =>
  if(s.isEmpty) None
  else          Some(da.decode(s))
}
```

And we can now decode optional values of any type that has a `CellDecoder` instance without any further work:

```tut
parseCsv[(Int, Option[String], Boolean)](Source.fromString(input)).toList
```

I might be flogging a dead horse at this point, but let's take another example to show how all these instances compose:
we've previously added instances of `RowDecoder` for all collection types whose elements had a `CellDecoder`, and we've
just created a `CellDecoder` instance for `Option[A]`, for all `A`s that have a `CellDecoder` instance themselves. This
allows us to parse CSV rows as collections of options without any further work:

```tut
val input = "1,,2\n,3,4"

parseCsv[List[Option[Int]]](Source.fromString(input)).toList
```

We could do the same thing for rows that are lists of values that are either an int or an optional boolean, or any
combanation of the cell decoders we've declared so far.


## Case classes
Case classes are, unfortunately, not quite as easy to deal with. The problem comes from the fact that there is no
simple way to abstract over the arity of a case class - the number of fields it has (yes, you can use
[shapeless](https://github.com/milessabin/shapeless), and we eventually will, but that's not trivial). This forces us
to write one decoder for each possible number of fields, which is rather a lot of boilerplate.

Let's do so for a single arity, 2. We'd need, at the very least, to know the types of the case class' fields and how
to decode them. But that's not quite enough: it'll let us have the values for each field, but how do we turn them into
a new case class instance? we'll also need a function for that.

Here's what our implementation might look like:

```tut:silent
def caseClass2Decoder[A0, A1, C](f: (A0, A1) => C)(implicit d0: CellDecoder[A0], d1: CellDecoder[A1]): RowDecoder[C] =
  new RowDecoder[C] {
    override def decode(row: IndexedSeq[String]) = f(d0.decode(row(0)), d1.decode(row(1)))
  }
```

And this is honestly not bad, but we can still improve on it. That `f` parameter looks an awful lot like the `apply`
method that is generated automatically on the companion object of a case class', and it would be very convenient to be
able to just pass that as an argument. The problem is that this would assume that the order in which our case class'
fields have been declared exactly matches that of the cells in each CSV row, which is a fairly unreasonnable assumption
to make - it might *sometimes* be true, but it won't *always* be.

To solve this, we need to modify our decoder to accept the index of each field:

```tut:silent
def caseClass2Decoder[A0, A1, C](f: (A0, A1) => C)(i0: Int, i1: Int)(implicit d0: CellDecoder[A0], d1: CellDecoder[A1]): RowDecoder[C] =
  new RowDecoder[C] {
    override def decode(row: IndexedSeq[String]) = f(d0.decode(row(i0)), d1.decode(row(i1)))
  }
```

Note how we've not marked `caseClass2Decoder` as implicit: it has an explicit parameter, which means the implicit
resolution mechanism will never be able to use it. We'll need to create decoders for each case class by hand.

Let's do so for a simple case class. First, we must create the case class and its decoder:

```tut:silent
case class Person(id: Int, name: String)

implicit val personDecoder = caseClass2Decoder(Person.apply)(0, 1)
```

And we can now use it as we would any other `RowDecoder` we have declared so far:

```tut
val input = "1,Nicolas\n2,Jessica\n3,Matt"

parseCsv[Person](Source.fromString(input)).toList
```

## Tuples
Now that we have case classes, tuples are trivial: tuples *are* case classes, and fairly simple ones at that:
it's reasonnable in this context to expect fields to be declared in the correct order in each CSV row. With that in
mind, we can write a `Tuple2` decoder with ease:

```tut:silent
implicit def tuple2Decoder[A0, A1](implicit d0: CellDecoder[A0], d1: CellDecoder[A1]): RowDecoder[(A0, A1)] =
  caseClass2Decoder(Tuple2.apply[A0, A1])(0, 1)
```

Note how the `d0` and `d1` parameters are required, but not actually used, or at least not explicitly. That's something
we'll improve on in a further post.

And with that, all possible tuples of arity 2 are now supported by our CSV parser, provided the types they contain have
`CellDecoder` instances.

Try to see if you can work out the implicit resolution for the following, somewhat complex example:

```tut
val input = ",1\ntrue,2\nfoobar,3"

parseCsv[(Option[Either[Boolean, String]], Int)](Source.fromString(input)).toList
```


## Single values
The last example we'll take is rows that are composed of a single value:

```tut
val input = "1\n2\n3\n4"
```

Conceptually, this is actually very simple: each row is composed of a single cell, so all we need is a `CellDecoder` for
that and we're set. That is, if we have a `CellDecoder` for a type, we get a `RowDecoder` for free:

```tut:silent
implicit def row1Decoder[A](implicit da: CellDecoder[A]): RowDecoder[A] = new RowDecoder[A] {
  override def decode(row: IndexedSeq[String]) = da.decode(row(0))
}
```

This works just as expected:

```tut
parseCsv[Int](Source.fromString(input)).toList
```

But we can also use our more advanced, implicitly derived instances:

```tut
parseCsv[Option[Either[Int, Boolean]]](Source.fromString(input)).toList
```

# What next?
At this point, we've understood what need type classes fill, and seen how, thanks to Scala's implicit resolution
mechanism, we can provide a few well thought-out default implementations and let the compiler work out how to combine
them into more complex and useful ones.

We've seen, however, that case classes were very awkward and required a lot of boilerplate. This is a problem, since
case classes tend to be very common - especially in scenarii where, say, one needs to read data from a CSV file and
store it in a more useful fashion, such as in a database of some sort. Our
[next task](/2015/11/26/tcgu-part-3.html), then, will be to find a way to derive case class instances automatically.
